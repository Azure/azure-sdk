---
title: "General Guidelines: Implementation"
keywords: guidelines
permalink: general_implementation.html
folder: general
sidebar: general_sidebar
---

Once you have worked through an acceptable API surface, you can start implementing the service clients.

## Configuration

When configuring your client library, particular care must be taken to ensure that the consumer of your client library can properly configure the connectivity to your Azure service both globally (along with other client libraries the consumer is using) and specifically with your client library.

### Client configuration

{% include requirement/MUST id="general-config-global-config" %} use relevant global configuration settings either by default or when explicitly requested to by the user, for example by passing in a configuration object to a client constructor.

{% include requirement/MUST id="general-config-for-different-clients" %} allow different clients of the same type to use different configurations.

{% include requirement/MUST id="general-config-optout" %} allow consumers of your service clients to opt out of all global configuration settings at once.

{% include requirement/MUST id="general-config-global-overrides" %} allow all global configuration settings to be overridden by client-provided options. The names of these options should align with any user-facing global configuration keys.

{% include requirement/MUSTNOT id="general-config-behaviour-changes" %} change behavior based on configuration changes that occur after the client is constructed. Hierarchies of clients inherit parent client configuration unless explicitly changed or overridden. Exceptions to this requirement are as follows:

1. Log level, which must take effect immediately across the Azure SDK.
2. Tracing on/off, which must take effect immediately across the Azure SDK.

### Service-specific environment variables

{% include requirement/MUST id="general-config-envvars-prefix" %} prefix Azure-specific environment variables with `AZURE_`.

{% include requirement/MAY id="general-config-envvars-use-client-specific" %} use client library-specific environment variables for portal-configured settings which are provided as parameters to your client library. This generally includes credentials and connection details. For example, Service Bus could support the following environment variables:

* `AZURE_SERVICEBUS_CONNECTION_STRING`
* `AZURE_SERVICEBUS_NAMESPACE`
* `AZURE_SERVICEBUS_ISSUER`
* `AZURE_SERVICEBUS_ACCESS_KEY`

Storage could support:

* `AZURE_STORAGE_ACCOUNT`
* `AZURE_STORAGE_ACCESS_KEY`
* `AZURE_STORAGE_DNS_SUFFIX`
* `AZURE_STORAGE_CONNECTION_STRING`

{% include requirement/MUST id="general-config-envvars-get-approval" %} get approval from the [Architecture Board] for every new environment variable. 

{% include requirement/MUST id="general-config-envvars-format" %} use this syntax for environment variables specific to a particular Azure service:

* `AZURE_<ServiceName>_<ConfigurationKey>`

where _ServiceName_ is the canonical shortname without spaces, and _ConfigurationKey_ refers to an unnested configuration key for that client library.

{% include requirement/MUSTNOT id="general-config-envvars-posix-compatible" %} use non-alpha-numeric characters in your environment variable names with the exception of underscore. This ensures broad interoperability.

## Parameter validation

The service client will have several methods that perform requests on the service.  _Service parameters_ are directly passed across the wire to an Azure service.  _Client parameters_ are not passed directly to the service, but used within the client library to fulfill the request.  Examples of client parameters include values that are used to construct a URI, or a file that needs to be uploaded to storage.

{% include requirement/MUST id="general-params-client-validation" %} validate client parameters.

{% include requirement/MUSTNOT id="general-params-server-validation" %} validate service parameters.  This includes null checks, empty strings, and other common validating conditions. Let the service validate any request parameters.

{% include requirement/MUST id="general-params-check-devex" %} validate the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service.  If the developer experience is compromised due to service-side error messages, work with the service team to correct prior to release.

## Network requests

Each supported language has an Azure Core library that contains common mechanisms for cross cutting concerns such as configuration and doing HTTP requests.

{% include requirement/MUST id="general-requests-use-pipeline" %} use the HTTP pipeline component within Azure Core for communicating to service REST endpoints.

The HTTP pipeline consists of a HTTP transport that is wrapped by multiple policies. Each policy is a control point during which the pipeline can modify either the request and/or response. We prescribe a default set of policies to standardize how client libraries interact with Azure services.  The order in the list is the most sensible order for implementation.

{% include requirement/MUST id="general-requests-implement-policies" %} implement the following policies in the HTTP pipeline:

- Telemetry
- Unique Request ID
- Retry
- Authentication
- Response downloader
- Distributed tracing
- Logging

{% include requirement/SHOULD id="general-requests-use-azurecore-impl" %} use the policy implementations in Azure Core whenever possible.  Do not try to "write your own" policy unless it is doing something unique to your service.  If you need another option to an existing policy, engage with the [Architecture Board] to add the option.

## Authentication

When implementing authentication, don't open up the consumer to security holes like PII (personally identifiable information) leakage or credential leakage.  Credentials are generally issued with a time limit, and must be refreshed periodically to ensure that the service connection continues to function as expected.  Ensure your client library follows all current security recommendations and consider an independent security review of the client library to ensure you're not introducing potential security problems for the consumer.

{% include requirement/MUSTNOT id="general-authimpl-no-persisting" %} persist, cache, or reuse security credentials.  Security credentials should be considered short lived to cover both security concerns and credential refresh situations.  

If your service implements a non-standard credential system (that is, a credential system that is not supported by Azure Core), then you need to produce an authentication policy for the HTTP pipeline that can authenticate requests given the alternative credential types provided by the client library.

{% include requirement/MUST id="general-authimpl-provide-auth-policy" %} provide a suitable authentication policy that authenticates the HTTP request in the HTTP pipeline when using non-standard credentials.  This includes custom connection strings, if supported.

## Native code

Some languages support the development of platform-specific native code plugins.  These cause compatibility issues and require additional scrutiny.  Certain languages compile to a machine-native format (for example, C or C++), whereas most modern languages opt to compile to an intermediary format to aid in cross-platform support.

{% include requirement/SHOULD id="general-no-nativecode" %} write platform-specific / native code unless the language compiles to a machine-native format.

## Error handling

Error handling is an important aspect of implementing a client library.  It is the primary method by which problems are communicated to the consumer.  There are two methods by which errors are reported to the consumer.  Either the method throws an exception, or the method returns an error code (or value) as its return value, which the consumer must then check.  In this section we refer to "producing an error" to mean returning an error value or throwing an exception, and "an error" to be the error value or exception object.  

{% include requirement/SHOULD id="general-errors-prefer-exceptions" %} prefer the use of exceptions over returning an error value when producing an error.

{% include requirement/MUST id="general-errors-for-failed-requests" %} produce an error when any HTTP request fails with an HTTP status code that is not defined by the service/Swagger as a successful status code. These errors should also be logged as errors.

{% include requirement/MUST id="general-errors-include-request-response" %} ensure that the error produced contains the HTTP response (including status code and headers) and originating request (including URL, query parameters, and headers).  

In the case of a higher-level method that produces multiple HTTP requests, either the last exception or an aggregate exception of all failures should be produced.

{% include requirement/MUST id="general-errors-rich-info" %} ensure that if the service returns rich error information (via the response headers or body), the rich information must be available via the error produced in service-specific properties/fields.

{% include requirement/SHOULDNOT id="general-errors-no-new-types" %} create a new error type unless the developer can perform an alternate action to remediate the error.  Specialized error types should be based on existing error types present in the Azure Core package.

{% include requirement/MUSTNOT id="general-errors-use-system-types" %} create a new error type when a language-specific error type will suffice.  Use system-provided error types for validation.

{% include requirement/MUST id="general-errors-documentation" %} document the errors that are produced by each method (with the exception of commonly thrown errors that are generally not documented in the target language).

## Logging

Client libraries must support robust logging mechanisms so that the consumer can adequately diagnose issues with the method calls and quickly determine whether the issue is in the consumer code, client library code, or service.

{% include requirement/MUST id="general-logging-pluggable-logger" %} support pluggable log handlers.

{% include requirement/MUST id="general-logging-console-logger" %} make it easy for a consumer to enable logging output to the console. The specific steps required to enable logging to the console must be documented. 

{% include requirement/MUST id="general-logging-levels" %} use one of the following log levels when emitting logs: Verbose (details), Informational (things happened), Warning (might be a problem or not), and Error.

{% include requirement/MUST id="general-logging-failure" %} use the Error logging level for failures that the application is unlikely to recover from (out of memory, etc.).

{% include requirement/MUST id="general-logging-warning" %} use the Warning logging level when a function fails to perform its intended task. This generally means that the function will raise an exception.  Do not include occurrences of self-healing events (for example, when a request will be automatically retried).

{% include requirement/MUST id="general-logging-info" %} use the Informational logging level when a function operates normally.

{% include requirement/MUST id="general-logging-verbose" %} use the Verbose logging level for detailed troubleshooting scenarios. This is primarily intended for developers or system administrators to diagnose specific failures.

{% include requirement/MUSTNOT id="general-logging-no-sensitive-info" %} send sensitive information in log levels other than Verbose. For example, remove account keys when logging headers.

{% include requirement/MUST id="general-logging-requests" %} log request line and dynamically generated headers as an Informational message. The format of the log should be the following:

```
REQUEST(id={request-id}, try={#}): {METHOD} {url} ["header"="value"...]
```

For example (this should be on a single line, but is folded for readability):

```
REQUEST(id=4a0ed94c-2559-4935-7e11-7c36987b1a61, try=1): 
    GET https://vstsimages.blob.core.windows.net/vhds/MMS.M141.VS2017.1.vhd?se=2018-11-07t21%3A58%3A08z&sig=REDACTED&sp=r&spr=https&sr=b&st=2018-10-24t12%3A58%3A08z&sv=2017-11-09&timeout=901 
    "x-ms-range"="bytes=327155712-335544319" 
    "x-ms-version"="2018-03-28"
    ...
```

{% include requirement/MUST id="general-logging-responses" %} log response line and headers as an Informational message.  The format of the log should be the following:

```
RESPONSE(id={request-id}, status={code}, message="{message}"): ["header"="value"...]
```

For example (this should be on a single line, but is folded for readability):

```
RESPONSE(id=4a0ed94c-2559-4935-7e11-7c36987b1a61, status=206, message="Partial Content"): 
    "Accept-Ranges"="bytes" 
    "Content-Length"="8388608" 
    "Content-Range"="bytes 327155712-335544319/136367309312" 
    "Content-Type"="application/octet-stream" "ETag"="0x8D62305BCB84262" 
    ...
```

{% include requirement/MUST id="general-logging-cancellations" %} log an Informational message if a service call is cancelled.  The format of the log should be the following:

```
CANCELLED(id={request-id}): {extended-reason, if available}
```

For example:

```
CANCELLED(id=4a0ed94c-2559-4935-7e11-7c36987b1a61)
```

{% include requirement/MUST id="general-logging-exceptions" %} log exceptions thrown as a Warning level message. If the log level set to Verbose, append stack trace information to the message.

### Default Logging

Logging for consumers is generally opt-in and aids the consumer in diagnosis of problems with their code and potential service issues.  However, there are cases where we require default logging, primarily in customer support situations.  The main goal of default logging is to improve customer satisfaction with the service when used in combination with the Azure SDK.  If a consumer requests support from Microsoft for a service operation via the client library, certain information is required in order to diagnose the issue.  We want to ensure that information is always available.  The Azure SDK supports several languages on several operating systems and within several app models.  As such, logging is not always available nor is it advisable in all situations.

{% include requirement/MUST id="fulcrum-logging-required" %} enable default logging when the `TEMP` environment variable exists and file system APIs are available.  The `TEMP` environment variable must point to a writable directory on the filesystem.  In cases where there is no file system, default logging is not available.

{% include requirement/MUSTNOT id="fulcrum-logging-prohibited" %} enable default logging if the platform does not allow user access to the file system.  For example, mobile environments generally have a file system that is not user accessible.

{% include requirement/MUST id="fulcrum-logging-optout" %} allow the consumer to opt out of default logging. 

The consumer should be able to opt out as follows:

* Globally by setting a `AZURE_DISABLE_DEFAULT_LOGGING` environment variable.
* On a per-client basis by setting a `disableDefaultLogging` client option to true.

{% include requirement/MUST id="fulcrum-logging-where" %} write logs to a sub-directory of the `TEMP` folder named `azurelogs`.  Logs for all service clients should write to the same log file as this allows CSS to identify cross-service issues more easily.

{% include requirement/MUST id="fulcrum-logging-limit-1" %} limit the maximum size of the default log file to a reasonable size, and restrict the number of log files written.  The default logging should strive to never cause an "out of disk space" error in normal operation by cleaning up after itself and be self-maintaining.

{% include requirement/SHOULD id="fulcrum-logging-limit-2" %} strive to minimize the performance effect of default logging.  

{% include requirement/MUST id="fulcrum-logging-requests" %} log the following information when a log message needs to be written:

* Time stamp
* Request ID
* REQUEST (method and URI)
* White listed request headers (redacted as necessary to preserve PII protection)
* RESPONSE (status code and message)
* White listed response headers (redacted as necessary to preserve PII protection)
* The time period between REQUEST and RESPONSE
* Any operating system level metrics the service deems important to diagnosing common issues (such as memory utilization or CPU load)

{% include requirement/MUST id="fulcrum-logging-pii" %} redact query parameters in the URI that are not white listed.

{% include requirement/MUST id="fulcrum-logging-failures" %} generate a log message when an I/O failure occurs (such as endpoint cannot be found or no connection established).

{% include requirement/MUST id="fulcrum-logging-failure-status" %} generate a log message when a failure HTTP status code is received.

{% include requirement/MUST id="fulcrum-logging-failure-slow" %} generate a log message when the request takes a long time (as defined by the service).

{% include requirement/MUSTNOT id="fulcrum-logging-no-bodies" %} log the body of the request or response.  These tend to be large and will create a significant overhead if logged.

There are no "log levels" in default logging as all logs are written to the same log file.  A client library will need to define two white lists for default logging:

1. Query parameters that can be safely logged because no PII exists.
2. Request and response headers that can be safely logged because no PII exists.

If a query parameter or header is not in the white list, then it **MUST** be redacted to avoid PII exposure to customer support services.

## Distributed Tracing

Distributed tracing mechanisms allow the consumer to trace their code from frontend to backend. The distributed tracing library creates spans - units of unique work.  Each span is in a parent-child relationship.  As you go deeper into the hierarchy of code, you create more spans.  These spans can then be exported to a suitable receiver as needed.  To keep track of the spans, a _distributed tracing context_ (called a context in the remainder of this section) is passed into each successive layer.  For more information on this topic, visit the [OpenTelemetry] topic on tracing.

{% include requirement/MUST id="general-tracing-opentelemetry" %} support [OpenTelemetry] for distributed tracing.

{% include requirement/MUST id="general-tracing-accept-context" %} accept a context from calling code to establish a parent span.

{% include requirement/MUST id="general-tracing-pass-context" %} pass the context to the backend service through the appropriate headers (`traceparent`, `tracestate`, etc.) to support [Azure Monitor].  This is generally done with the HTTP pipeline.

{% include requirement/MUST id="general-tracing-new-span-per-method" %} create a new span for each method that user code calls.  New spans must be children of the context that was passed in.  If no context was passed in, a new root span must be created.

{% include requirement/MUST id="general-tracing-new-span-per-rest-call" %} create a new span (which must be a child of the per-method span) for each REST call that the client library makes.  This is generally done with the HTTP pipeline.

Some of these requirements will be handled by the HTTP pipeline.  However, as a client library writer, you must handle the incoming context appropriately.

## Dependencies

Dependencies bring in many considerations that are often easily avoided by avoiding the 
dependency. 

- **Versioning** - Many programming languages do not allow a consumer to load multiple versions of the same package. So, if we have an client library that requires v3 of package Foo and the consumer wants to use v5 of package Foo, then the consumer cannot build their application. This means that client libraries should not have dependencies by default. 
- **Size** - Consumer applications must be able to deploy as fast as possible into the cloud and move in various ways across networks. Removing additional code (like dependencies) improves deployment performance.
- **Licensing** - You must be conscious of the licensing restrictions of a dependency and often provide proper attribution and notices when using them.
- **Compatibility** - Often times you do not control a dependency and it may choose to evolve in a direction that is incompatible with your original use.
- **Security** - If a security vulnerability is discovered in a dependency, it may be difficult ortime consuming to get the vulnerability corrected if Microsoft does not control the dependencys code base.

{% include requirement/MUST id="general-dependencies-azure-core" %} depend on the Azure Core library for functionality that is common across all client libraries.  This library includes APIs for HTTP connectivity, global configuration, and credential handling.

{% include requirement/MUSTNOT id="general-dependencies-approved-only" %} be dependent on any other packages within the client library distribution package. Dependencies are by-exception and need a thorough vetting through architecture review.  This does not apply to build dependencies, which are acceptable and commonly used.

{% include requirement/SHOULD id="general-dependencies-vendoring" %} consider copying or linking required code into the client library in order to avoid taking a dependency on another package that could conflict with the ecosystem. Make sure that you are not violating any licensing agreements and consider the maintenance that will be required of the duplicated code. ["A little copying is better than a little dependency"][1] (YouTube).

{% include requirement/MUSTNOT id="general-dependencies-concrete" %} depend on concrete logging, dependency injection, or configuration technologies (except as implemented in the Azure Core library).  The client library will be used in applications that might be using the logging, DI, and configuration technologies of their choice.

Language specific guidelines will maintain a list of approved dependencies.

## Service-specific common library code

There are occasions when common code needs to be shared between several client libraries.  For example, a set of cooperating client libraries may wish to share a set of exceptions or models.

{% include requirement/MUST id="general-commonlib-approval" %} gain [Architecture Board] approval prior to implementing a common library.

{% include requirement/MUST id="general-commonlib-minimize-code" %} minimize the code within a common library.  Code within the common library is available to the consumer of the client library and shared by multiple client libraries within the same namespace.

{% include requirement/MUST id="general-commonlib-namespace" %} store the common library in the same namespace as the associated client libraries.

A common library will only be approved if:

* The consumer of the non-shared library will consume the objects within the common library directly, AND
* The information will be shared between multiple client libraries.

Let's take two examples:

1. Implementing two Cognitive Services client libraries, we find a model is required that is produced by one Cognitive Services client library and consumed by another Coginitive Services client library, or the same model is produced by two client libraries.  The consumer is required to do the passing of the model in their code, or may need to compare the model produced by one client library vs. that produced by another client library.  This is a good candidate for choosing a common library.

2. Two Cognitive Services client libraries throw an `ObjectNotFound` exception to indicate that an object was not detected in an image.  The user might trap the exception, but otherwise will not operate on the exception.  There is no linkage between the `ObjectNotFound` exception in each client library.  This is not a good candidate for creation of a common library (although you may wish to place this exception in a common library if one exists for the namespace already).  Instead, produce two different exceptions - one in each client library.

## Testing

One of the key things we want to support is to allow consumers of the library to easily write repeatable unit-tests for their applications without activating a service.  This allows them to reliable and quickly test their code without worrying about the vagaries of the underlying service implementation (including, for example, network conditions or service outages).  Mocking is also helpful to simulate failures, edge cases, and hard to reproduce situations (for example: does code work on February 29th).

{% include requirement/MUST id="general-testing-mocking" %} support mocking of network operations.

{% include refs.md %}

[OpenTelemetry]: https://opentelemetry.io
[Azure Monitor]: https://azure.microsoft.com/services/monitor/
[1]: https://www.youtube.com/watch?v=PAAkCSZUG1c&t=9m28s