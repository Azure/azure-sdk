---
title: "General Guidelines: Compatibility"
keywords: guidelines
permalink: general_compatibility.html
folder: general
sidebar: general_sidebar
---

This section describes guidelines related to compatibility. In particular, it describes high-level compatibility principles, and detailed rules for reasoning about API and behavioral changes introduced as we evolve our libraries.

## Compatibility Principles
One of the main general principles of the Azure SDK is that it is **Dependable**, and one of the main aspects of dependability is a high level of compatibility. 

In the context of these guideline, compatibility means that software written using one version of our libraries should function correctly when upgraded to a newer version of the same library, as long as it calls the same version of the service REST API as it was calling before the upgrade.
This is to ensure that developers using the Azure SDK can upgrade to new versions of our libraries without immediately being subjected to a large cost of fixing resulting breaks. 
This is good for our customers, as it lowers their costs, and it's good for us, as it helps in the adoption of new Azure features, i.e. a win-win.

Having said that, you can always imagine code, even if contrived, that will break when upgraded to a new version of a library that simply adds functionality, fixes bugs, or runs faster. 
Also, there are some incompatible changes that are worth doing, e.g. changes required to fix security bugs. 
And so given that absolute compatibility is not possible in practice, we want to be best-in-class, which as a rule of thumb means being on par with base libraries of the corresponding language.

Principle #1: Azure SDK libraries must be as compatible or better than the base libraries of their language. For example, Azure SDK for .NET libraries must be as compatible as the .NET Base Class Libraries.

### Azure SDK Compatibility Reviews
Azure SDK guidelines define details of what's considered a compatible change in each language ecosystem. All changes that are not explicitly designated as compatible, need to be reviewed and approved by the Azure SDK Architecture Board. 

### API Changes
It might seem that additions to the APIs would be non-breaking, and removals would be breaking. Unfortunately, it's not as simple. Languages differ quite significantly in terms of what API changes would result in breaks in the caller. In particular, there are very significant differences between dynamic and static languages. Therefore, you should refer to language specific guidelines for details of what constitutes an acceptable API change.

Behavioral compatibility is more language independent, and so it's described below. 

### Behavioral Changes

TBD

#### Logging Changes
Changes to the output of logs generated by a library are treated separately from other behavioral change, and they are described in this section.

Many customers build scripts and tools that automatically analyze logs. Just like we don't want software calling our APIs to break when the software is upgraded to new versions of our libraries, we don't want log analysis tools and scripts to break.

Logs can be seen as a sequence of entries, and entries can be seen as a sequence of tokens that can be parsed by tools. Entry tokens can be further divided into schema related tokens (i.e. tokens that don't vary between instances of entries), and data tokens (tokens that can, and often do, vary between instances of entries, e.g. the time when an entry was logged).

Changes allowed in a new major or minor version of a package (not a patch version):

- Additional log entries, e.g. new version logs request details on every retry, while the old version logged only once per retry.
- Additional entry types (entries with a new schema).

All other changes allowed only when:

- Approved by the Azure SDK Architecture Board, and 
- User must opt into the new behavior by specifying a new API version or a client option.
