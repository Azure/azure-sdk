## Java tooling {#java-tooling}

The two primary tools used to ensure conformance and high quality are SpotBugs and CheckStyle. The Java client libraries are aided by the addition of custom checks that ensure partial conformance to this Java specification document, with more checks added as necessary. Assuming the client library exists in the azure-sdk-for-java repository, there are two commands to execute from the root directory that will generate these reports:

1. To install tooling (and generate the SpotBugs report): `mvn install -Dinclude-non-shipping-modules -DskipTests -Dgpg.skip -f pom.client.xml`
2. To run all other reports: `mvn site:site site:stage -DskipTests -Dgpg.skip -f pom.client.xml`

Once these two commands are executed, the generated reports are available in the following locations:

| Tool       | Output Location                                                   |
|------------|-------------------------------------------------------------------|
| SpotBugs   | `/eng/spotbugs-aggregate-report/target/spotbugs/spotbugsXml.html` |
| CheckStyle | `/target/staging/checkstyle-aggregate.html`                       |
| JavaDoc    | `/target/staging/apidocs/index.html`                              |
| Maven Site | `/target/staging/index.html`                                      |

### SpotBugs

~ Must {#java-tooling-code-linter}
run SpotBugs using the centralised Azure Java SDK SpotBugs rule set, and ensure that there are no failures being reported.
~

~ MustNot {#java-tooling-code-linter-test-no-commit-on-failure}
push code to a repo that breaks SpotBugs. Because the build is set to fail if any SpotBugs issue is found, it should always be a case that the build can complete successfully before any code is committed and pushed.
~

### CheckStyle

~ Must {#java-tooling-code-style}
run CheckStyle, in a similar fashion to SpotBugs above. There must be no failures.
~

### JaCoCo

Unit tests, as covered in the next section, are an important means of ensuring that our code does what we expect it to, and that it continues to do what we expect as the codebase is developed in future releases. Having a sense of how well our codebase is covered in tests is therefore a useful goal, and this is where [JaCoCo](https://www.eclemma.org/jacoco/) can be useful - it generates HTML reports stating the coverage our unit tests have on the codebase.

~ Must {#java-test-coverage}
ensure that code test coverage is satisfactory by producing a JaCoCo report using `mvn jacoco:report`.
~