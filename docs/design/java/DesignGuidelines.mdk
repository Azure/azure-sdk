## Scope {#java-scope; @h1-h2: decimal; }

~ Must {#java-scope-inclusion}
use the `com.azure` group ID for all Java Azure SDK components.
~

## Terminology

- **Azure SDK Component**: An Azure SDK component (also referred to as 'SDK component', or simply 'component') represents the software (and associated tools, documentation, samples, etc) that exists to support a single Azure service. Each Azure SDK component will be published separately to Maven Central under a common `com.azure` groupId, but with a unique `artifactId`. These releases are performed exclusively by the Azure SDK engineering systems team. Developers will be able to consume and use each component separately as necessary to solve their use case.
- **SDK**: Software Development Kit. This refers to the entire Azure SDK for Java, itself broken up into numerous Azure SDK Components as defined above.
- **Snapshot Releases**: These are releases made to Maven Central that have a semver version number of the form `x.y.z-SNAPSHOT`. Snapshot releases go into a separate directory on Maven Central, and version numbers do not need to be incremented or changed for each snapshot release (instead, the next release version number should be used, with `-SNAPSHOT` appended). These releases can be made as frequently as desired, and can be considered preview or beta quality. They can be released automatically as part of a CI/CD process. Users of snapshot releases have to opt-in to using the snapshots repository by explicitly referencing it from their own Maven pom.xml file.
- **Preview Releases**: A preview release is an alpha, beta, or release candidate release into the main Maven Central repository. This means that the user does not need to opt-in as in snapshot releases. Preview releases should follow the guidance below on what to append to the version string. Preview releases must be made through the engineering systems pipeline.
- **GA Releases**: Anything that is not a snapshot or preview release should be considered an official GA release. Official releases must be done only once per version increment, and must only be done through the engineering system pipeline.

## Pre-requisites

~ MustNot {#java-stable-service}
make a GA release of a SDK component until the underlying service is also in GA, with a stable protocol. 
~

~ MustNot {#java-stable-swagger}
make a GA release of a SDK component for a service whose protocol is based on a REST API until there is a stable GA Swagger specification available.
~

## Functionality

~ Must {#java-support-all-service-features}
support 100% of the features provided by the Azure service the SDK component represents. Gaps in functionality cause confusion and frustration among developers.
~

## Platform Support

### Operating Systems

~ MustNot {#java-no-native-code}
write platform-specific / native code. If any such code is required for proper functioning of the SDK component, it should be specifically called out as part of the review process and appropriate justification provided.
~

~ Must {#java-test-sample-apps-on-all-operating-systems}
test that sample apps execute as expected on all three major platforms.
~

~ May {#java-android-support}
test against Android to ensure compatibility.
~

### Supported Java Versions

All Azure SDK components are baselined on Java 8.

~ MustNot {#java-do-not-exceed-jdk-baseline-features}
use any language or API feature from a release of Java beyond Java 8. 
~

~ Must {#java-ensure-jdk-baseline-compilation}
test to ensure that all code compiles and runs as expected on Java 8.
~

~ Must {#java-ensure-jdk-lts-compilation}
compile against the latest Java long-term support release, to ensure that code continues to compile, and unit tests continue to run and pass. It is critical that when this is performed, that the Maven build configuration is temporarily adjusted to use the Java LTS APIs only.
~

~ Must {#java-jdk-build-target}
build and test SDK components against OpenJDK, rather than Oracle JDK or any other JDK build.
~

## Versioning

~ Must {#java-use-semver}
ensure that all Maven releases are versioned using [semantic versioning](https://semver.org/).
~

~ MustNot {#java-no-0-majors}
have releases of SDK components with a major version of 0, even for early preview releases.
~

### Snapshot Releases

~ Must {#java-use-deprecated-for-feature-dev}
use the `@Deprecated` annotation and the `@deprecated` JavaDoc tag for features that are under development within a snapshot release, and which may change before GA.
~

~ Must {#java-explain-experimental-features}
provide sufficient explanation to clarify that the API is experimental and may change before the next GA release.
~

~ MustNot {#java-no-deprecated-preview-in-GA}
release a GA release with any such deprecated annotations.
~

### Preview Releases

Preview releases are made when code hits certain milestones and wider community adoption and testing is warranted. Preview releases replace the `-SNAPSHOT` qualifier with either an `-alpha`, `-beta`, or `-rc` (release candidate) qualifier, depending on the maturity of the code being released.

~ Must {#java-preview-qualifer-required}
have a qualifier of `-alpha`, `-beta`, or `-rc` for all preview releases.
~

~ Must {#java-preview-qualifier-numbering}
have an incrementing number appended directly to the end of the preview qualifier. For example, `-beta1`, `-beta2`, etc.
~

~ Must {#java-preview-version-next-GA}
have the version number represent the version intended for the next GA release. For example, a preview release of `1.0.2-beta2` should be read to mean that it is the second beta release of version 1.0.2, and that this release will be superceded by the GA release of 1.0.2 when it becomes available.
~

### GA Releases

~ Must {#java-use-deprecated-for-retiring-api}
use the `@Deprecated` annotation and the `@deprecated` JavaDoc tag when a feature is to be removed in a future major release. Explain what is being removed, and how developers should transition to new API.
~

~ MustNot {#java-do-not-change-api-in-non-major-release}
remove or change API in any release that is not a major version change.
~

~ MustNot {#java-must-indicate-deprecation-before-change}
remove or change API until there has been at least one GA release that contains the deprecation notices in the code. This enables developers to receive deprecation warnings at build time in their development projects.
~

~ MustNot {#java-no-deprecated-in-GA}
do a major GA release if there is any API marked as deprecated.
~

~ MustNot {#java-no-qualifier-in-GA}
release any SDK component as GA with a snapshot or preview release qualifier.
~

## Naming

To make understanding our Azure SDK simpler, it is important that we apply a consistent naming policy across all of them. There are a few aspects to this: Java package names, as well as our `groupId` and `artifactId` names for use in our Maven pom.xml file. This section will cover how to determine the group and service name to use in your SDK components name, as well as how Java packages are named, but will leave the Maven pom.xml guidance until a later section in this specification.

### Determing Group and Service Name

~ Todo
Refer reader to external document that details how to determine which group and service name an SDK component should use.
~

### Java Package Naming

~ Must {#java-consistent-package-naming}
use the package naming pattern of all lowercase letters (no camel case is allowed), without spaces, hyphens, or underscores. For example, Azure Key Vault would be in `com.azure.<group>.keyvault` - note that the two words 'Key' and 'Vault' are brought together to `keyvault`, instead of `keyVault`, `key_vault`, or `key-vault`.
~

~ Todo
Link to shared doc on group naming scheme
~

~ Must {#java-consistent-package-structure}
ensure that all code for an SDK component resides in a package which takes the form `com.azure.<group>.<service>[.<feature>]`. Sub-packages are fine and can be named as appropriate.
~

~ MustNot {#java-do-not-leak-impl}
allow implementation code (i.e. code that does not form part of the public API) to be mistaken as public API. There are two valid arrangements for implementation code, one (or both) of which must be followed:

1. Implementation classes can be placed within a subpackage named `implementation`.
2. Implementation classes can be made package-private and placed within the same package as the consuming class.
~

## Maven Projects

The Azure SDK, and all SDK components, will be standardized on Maven as the system to handle build and dependency management. By employing a single tool across all SDK components, builds can be related to each other to enable centralized management of build configuration and dependency versioning.

### Project Initialization

~ Must {#java-initialize-using-maven}
initialize a brand new Maven project for each SDK component, using the [instructions provided at maven.apache.org](https://maven.apache.org/guides/getting-started/index.html#How_do_I_make_my_first_Maven_project), by running the following Maven archetype (refer to the section below to determine the groupId and artifactId to use):

```
mvn -B archetype:generate \
  -DarchetypeGroupId=org.apache.maven.archetypes \
  -DgroupId=com.azure \
  -DartifactId=my-service
```

The following is the canonical file structure of your project after Maven has initialized it with the command shown above:

```
my-app
|-- pom.xml
`-- src
    |-- main
    |   `-- java
    |       `-- com
    |           `-- azure
    |               `-- Service.java
    `-- test
        `-- java
            `-- com
                `-- azure
                    `-- ServiceTest.java
```

SDK component developers must ensure that all SDK components follow these conventions. SDK components may include other files in addition to this.
~

Projects that decompose into multiple submodules work by effectively introducing an intermediate parent POM that groups together all children modules, but from the root POM there remains only the one POM that it cares about. Choosing to decompose a project into multiple submodules is a decision that an SDK component can make, but it should not be done without a good justification - in most cases a single module is the best approach. If you are interested, you can [read more about multi-module projects](https://books.sonatype.com/mvnex-book/reference/multimodule.html).

### pom.xml

The following sections describe the pom.xml file that must be included with every SDK component. The default pom.xml file generated by the Maven archetype above is not sufficient for creating a valid Azure SDK component. A compliant pom.xml file looks like the following:

~ Todo
Include valid pom.xml file
~

Not all elements of this pom.xml will be detailed in the sections below - only those where some thought must be applied to change the defaults to be specific to the specific SDK component.

~ Todo
Reference parent pom requirements (once it is specified).
~

#### parent

~ Must {#java-maven-use-parent-pom}
explicitly specify the Azure Java SDK parent POM file for all SDK components (as shown in the xml above). This enables centralized dependency and build tool management.
~

~ Must {#java-maven-multi-module-structure}
ensure that, in the case of a multi-module project, the root pom.xml for the SDK component must have as its parent the Azure SDK parent pom, and all children modules must specify their parent pom as the SDK component root pom.xml.
~

#### groupId

~ Must {#java-maven-groupid}
specify the `groupId` as `com.azure`.
~

#### artifactId

~ Must {#java-maven-artifactid}
specify the `artifactId` to be of the form `azure-<group>-<service>`, for example, `azure-storage-blob`. In cases where the SDK component has multiple children modules, it is acceptable for the root pom.xml `artifactId` to be of the form `azure-<group>-<service>-parent`.
~

#### name, description, and url

These three elements should be human-readable texts no more than a sentence in length. 

~ Must {#java-maven-name}
specify the `name` element to take the form `Microsoft Azure SDK component for <service name>`.
~

~ Must {#java-maven-description}
specify the `description` element to be a slightly longer statement along the lines of `This package contains Microsoft Azure Key Vault SDK component`.
~

~ Must {#java-maven-url}
specify the `url` element to point to the root of the GitHub repository containing this source code, which will be frequently (although not always or required to be) present at `https://github.com/Azure/azure-sdk-for-java`.
~

#### scm

~ Must {#java-maven-scm}
specify the source code management section, to specify where the source code resides for the SDK component. If the source code is located in the https://github.com/Azure/azure-sdk-for-java repository, then the following form must be used:

```
<scm>
    <url>scm:git:https://github.com/Azure/azure-sdk-for-java</url>
    <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>
    <tag>HEAD</tag>
</scm>
```

In cases where the repository storing the code for the SDK component is different, substitute as necessary to ensure the correct details are provided.
~

#### developers

~ MustNot {#java-maven-developers}
change the `developers` section of the pom.xml file - it must only list a developer `id` of `microsoft` and an `organization` of `Microsoft Corporation`. There must not be additional names added to represent the developers involved in the project.
~

## GitHub Requirements

~ Must {#java-github-open-source}
ensure that all library code is public and open source on GitHub. Library code must be either in the [Azure GitHub organization](https://github.com/Azure/) or a module in the [Azure SDK for Java](https://github.com/Azure/azure-sdk-for-java) repo. If an independent repo is used then the repository name must be `azure-[service-name]-java`.
~

~ Should {#java-github-be-open} 
develop in the open on GitHub. It is recommended to have your GitHub repo be set up and active at least a month prior to your initial release.
~

~ Must {#java-github-active}
remain active in GitHub. Your SDK component's GitHub repo is your primary touch point with the developer community so it's important to keep up with the activity there. Issues and pull requests on GitHub must have an authoritative comment within one week of filing.
~

~ Should {#java-github-review-open-source-guidelines}
review the Microsoft Open Source Guidelines' [community section](https://docs.opensource.microsoft.com/releasing/foster-your-community.html) for more information on fostering a healthy open-source community.
~

### README<span></span>.md

~ Must {#java-github-readme}
include in your GitHub repo a README<span></span>.md file that has the sections shown below. Rather than produce this from scratch, refer to the template readme<span></span>.md file and take that as a starting point.

- One paragraph introduction of the service
- Maven dependency fragment (with no version - link to central document for details on how to depend on Azure SDK BOM)
- Maven dependency fragment for latest snapshot release
- Documentation
  - Link to Javadoc
  - Link to relevant quick starts and tutorials
- Samples table
- Building and testing
  - Pre-requisites
  - Building
  - Running unit tests
  - Generating JavaDoc, SpotBugs, and CheckStyle reports
- Contributing
  - Must include a reference to the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct) and a link to the CONTRIBUTING.md file
  - Should encourage developers to seek support on Stack Overflow
~

~ Todo
Link to template version when it exists.
~

~ Todo
How to display previous releases? Have a table, use the GitHub releases feature, etc?
~

### CONTRIBUTING<span></span>.md

~ Must {#java-github-contributing}
include CONTRIBUTING<span></span>.md file in your GitHub repo, using it to describe the process by which contributors can make contributions to the project. Any relevant processes and procedures must be documented. An example CONTRIBUTING.md is provided by the [Microsoft Open Source Guidelines](https://docs.opensource.microsoft.com/releasing/overview.html):

```
# Contributing

This project welcomes contributions and suggestions. Most contributions require you to
agree to a Contributor License Agreement (CLA) declaring that you have the right to,
and actually do, grant us the rights to use your contribution. For details, visit
https://cla.microsoft.com.

When you submit a pull request, a CLA-bot will automatically determine whether you need
to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the
instructions provided by the bot. You will only need to do this once across all repositories using our CLA.

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).
For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/)
or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.
```
~

### LICENSE<span></span>.md

~ Must {#java-github-license}
include a LICENSE<span></span>.md file containing your license text.
~

### CODEOWNERS

CODEOWNERS is a GitHub standard to specify who is automatically assigned pull requests to review. This helps to prevent pull requests from languishing without review. GitHub can also be configured to require review from code owners before a pull request can be merged. Further reading is available from the following two URLs:

- [https://blog.github.com/2017-07-06-introducing-code-owners/](https://blog.github.com/2017-07-06-introducing-code-owners/)
- [https://help.github.com/articles/about-codeowners/](https://help.github.com/articles/about-codeowners/)

~ Must {#java-github-codeowners}
edit the root-level CODEOWNERS file to ensure that it is updated to redirect all pull requests for the directory of the SDK component to point to the relevant engineers of this component. If the SDK component will exist within its own repository, then a CODEOWNERS file must be introduced and configured appropriately.
~

## Dependencies

Each dependency we add to an SDK component increases its weight, and so it should be done with caution and careful consideration. Also, for every dependency we add, we increase the risk of having classpath collisions and dependency versioning issues.

~ MustNot {#java-no-new-dependencies}
introduce new dependencies on third party libraries, without first seeking permission from the Java architect.
~

~ MustNot {#java-no-dependency-version-overrides}
specify or change dependency versions in your SDK component pom.xml file. All dependency versioning must be centralized through the common parent POM (see the next section).
~

### The 'Parent POM'

A parent POM lists a large number of dependencies, including their Maven `groupId`, `artifactId`, and most importantly, their `version`. When individual SDK projects depend on this parent POM, they no longer have to specify the version number for their dependencies, as these will instead be inferred from the parent POM. This means that all projects that depend on this parent POM, assuming they specify no versions in their own POM files, will be consistently using the same version. In doing so, we can avoid many of the pitfalls of dependency management, commonly referred to in Java parlance as 'classpath hell'.

It is important to note that the parent POM does have many more dependencies listed in it than any one SDK component may require to build and run. This is OK - it is designed to be the superset of all dependencies for all children project after all - and this does not mean that all dependencies are added to the project. A parent POM should be thought of as simply a map of (Maven `groupId` + Maven `artifactId`) to Maven `version` number, and nothing more.

We do not intend to 'lead the pack' and always update to the latest version of all dependencies. We will instead be
fast followers by observing community preferences, keeping ourselves informed of where the wider Java community stands on versioning and keeping in step with that.

~ Must {#java-use-parent-pom}
use the parent POM outlined earlier in this document to refer upwards to the single, common parent.
~

#### Adding a New Dependency

Submit a pull request to add the dependency to the parent POM. It will be swiftly reviewed by the relevant people, discussed, and a decision will then be made.

#### Updating Existing Dependencies

The process for updating dependency versions is to use GitHub pull requests, and to centralise discussion within that pull request. There will be a representative from each team currently consuming the parent POM included in the CODEOWNERS file, so that all pull requests have them as code reviewers and as such notified of incoming proposals.

There will have a 3 business days time window for any dissenting opinions, after which time the pull request will be merged. If there is a disagreement, the discussion will happen in the GitHub pull request as to why, and how to proceed.

There may be rare times when a dependency in the parent POM is urgently needing to be upgraded, due to a security vulnerability being found, for example. Depending on how critical the issue is, there is a guarantee that communication will continue to happen in the standard process, however there may already be a commit and a new parent POM version ready for all SDK teams to upgrade to.

Because this new parent POM will have an updated version number, it will not impact any processes for child projects, as they will still depend on the previous release. Depending on how critical the issue is, the team responsible for maintaining this parent POM may also submit pull requests into all SDK repos to ensure they are updated to the new version.

## Coding Conventions

~ Must {#java-be-idiomatic}
ensure that all APIs are idiomatic for Java developers and follow best practices.
~

~ Should {#java-api-best-practices}
follow Java API design best practices. Refer to the [Java API Design Best Practices website](https://jonathangiles.net/presentations/java-api-design-best-practices/) for a DZone refcard and YouTube videos. Best practices such as immutable classes, using builders as necessary, using `final` appropriately, proper implementation of `hashCode` and `equals` methods, and so on are vital to the quality of an API.
~

~ Must {#java-client-naming-pattern}
use the suffix "Client" for types accessing the service (Ex. `CosmosClient`).
~

~ Must {#java-client-crud-operations}
prefer the use of the following terms for CRUD operations:

- `create<noun>`
- `replace<noun>`
- `update<noun>`
- `delete<noun>`
- `add<noun>`
- `remove<noun>`
~

### Async

Due to the nature of internet-based communication, asynchronous APIs are a must to ensure efficient use of system resources (threads and their stacks).

~ Must {#java-async-use-project-reactor}
use [Project Reactor](http://projectreactor.io) to provide end-users with a high-quality async API.
~

~ MustNot {#java-async-no-other-libs}
use any other approaches used, such as `CompletableFuture` and [RxJava](https://github.com/ReactiveX/RxJava).
~

~ MustNot {#java-async-no-sync-methods}
provide synchronous methods in addition to async methods - instead follow the policy that developers may choose to block on an asynchronous call to make it become synchronous.
~

~ MustNot {#java-no-async-naming-pattern}
use the suffix `Async` in methods that perform operations asynchronously. Instead, simply drop the suffix entirely (as all APIs should be async by default, it is a redundant piece of information).
~

~ MustNot {#java-async-no-overloads}
provide multiple asynchronous methods for a single REST endpoint, unless to provide overloaded methods to enable alternative or optional method parameters.
~

~ Must {#java-async-useful-return-type}
ensure that all Async methods return a type that contains all information to enable a developer to inspect the metadata related to the service call (e.g. for HTTP endpoints, the async method call must return a type that enables the developer to read the headers, status code, and all other useful information).
~

~ MustNot {#java-async-no-custom-API}
write custom APIs for streaming or async operations - make use of the existing functionality offered in the Azure Java SDK base class library. Where necessary, additional functionality should be introduced into the Azure Java SDK base class library after discussions with the Java architect.
~

### Pipelines

~ Must {#java-pipelines-use-existing-api}
use the existing pipelines APIs for all requests to Azure services, including any requirements for authentication, telemetry, logging, tracing, retries, cancellations, etc. Do not use other HTTP clients or means of connecting to Azure services.
~

~ Todo
Refer back to general guidelines doc.
~

### Logging

Logging is critical to provide developers insight into why things are operating the way they are, and to help diagnose issues that are preventing their successful use of our SDK.

~ Must {#java-logging-use-slf4j}
use the APIs provided by the [SLF4J](https://www.slf4j.org/) project, as this is the only logging API to be used in all Azure Java SDK components. Refer to the [SLF4J user manual](https://www.slf4j.org/manual.html) for additional guidance.
~

### Don't Return null

Sir Tony Hoare called the invention of the null reference (something he created) his '[billion-dollar mistake](https://en.wikipedia.org/wiki/Tony_Hoare)'. In Java we have become so accustomed to handling error conditions by returning `null` that it is second nature to null check everything, but in many cases there are better options. Refer to the table below for some common examples:

| Return Type               | Non-null Return Value                                                             |
|---------------------------|-----------------------------------------------------------------------------------|
| String                    | `""` (An empty string)                                                            |
| List / Set Map / Iterator | Use the `Collections` class, e.g. `Collections.emptyList()`                       |
| Stream                    | `Stream.empty()`                                                                  |
| Array                     | Return an empty, zero-length array                                                |
| All other types           | Consider using `Optional` (but read the `Optional` section later in this refcard) |

In guaranteeing to return non-null values to callers of our API, our users can opt to not include the noisiness of the null check in their code base. It is important however, that should this approach be taken, that we ensure that it is applied consistently across an entire API. It is very easy to erode trust in an API if it fails to consistently apply patterns (and in failing to do so, causes the user to encounter unexpected null pointer exceptions).

### Functional Interfaces

In Java 8 the `@FunctionalInterface` annotation was introduced, allowing API designers to designate that a particular class is intended for use in lambda expressions. It is not necessary that a class have this annotation, but by having this associated with a class, it enables the compiler to enforce that the class has exactly one abstract method, which is the requirement for supporting lambda expressions.

From a developers point of view this is beneficial as it ensures that a class intended for use in lambda expressions does not accidentally lose that ability with the introduction of additional abstract methods - because the compiler will not allow this situation to arise.

Having said this, developers should have some reticence to creating their own functional interfaces, as recent releases of the JDK ship with 43 functional interfaces baked in. These can be broken down into six categories, each outlined below:

| Interface           | Signature             |
|---------------------|-----------------------|
| `UnaryOperator<T>`  | `T apply(T t)`        |
| `BinaryOperator<T>` | `T apply(T t1, T t2)` |
| `Predicate<T>`      | `boolean test(T t)`   |
| `Function<T,R>`     | `R apply(T t)`        |
| `Supplier<T>`       | `T get()`             |
| `Consumer<T>`       | `void accept(T t)`    |

Developers can choose to use these functional interfaces in lieu of creating their own, but there are still valid reasons for creating a custom functional interface. Examples include wanting a more descriptive name for the interface (for example, `Comparator` is a very expressive name for the function it serves), and wanting to introduce additional functionality (default methods in interfaces, or non-abstract methods in classes).

### Tooling

#### IDE Configuration

As it appears most engineers reading this document have standardised on IntelliJ IDEA for their IDE choice, a repository has been made available containing code style and inspection rules. Enabling these configuration settings in IntelliJ IDEA will ensure that all engineers will be generating code that conforms to a shared style standard, with fewer bugs and improved consistency.

~ Must {#java-tooling-ide-config}
install the addons following the [instructions provided](https://github.com/JonathanGiles/java-code-styles), and ensure that any reported warnings are resolved before GA.
~

#### SpotBugs

~ Must {#java-tooling-run-spotbugs}
run SpotBugs using the centralised Azure SDK SpotBugs rule set. As all projects must have a Maven inheritance hierarchy that includes the Azure SDK Maven pom.xml, this is configured automatically, and the tooling will execute by calling `mvn spotbugs:spotbugs`. It will also execute as part of the build process, failing the build if any SpotBugs issue is found.
~

~ MustNot {#java-tooling-spotbugs-test-no-commit-on-failure}
push code to a repo that breaks SpotBugs. Because the build is set to fail if any SpotBugs issue is found, it should always be a case that the build can complete successfully before any code is committed and pushed. If a build fails, a SpotBugs HTML report can be generated by calling `mvn spotbugs:spotbugs` on the command line. This report will provide context about the failure and point the developer towards fixing it.
~

#### CheckStyle

~ Must {#java-tooling-run-checkstyle}
run CheckStyle, in a similar fashion to SpotBugs above. All relevant rules will be run on each build. Whilst CheckStyle failures are less critical, all failures must be resolved prior to a GA release. If a build fails, a CheckStyle HTML report can be generated by calling `mvn checkstyle:checkstyle` on the command line. This report will provide context about the failure and point the developer towards fixing it.
~

### Testing

#### Unit Tests

~ Must {#java-testing-have-unit-tests}
write unit tests to ensure that the code operates as expected. A test suite should be included with each SDK component to ensure code operates as specified, and to protect against regressions.
~

~ Must {#java-testing-complete}
ensure that the unit tests cover important code paths and that all branches in these code paths are tested comprehensively.
~

#### Mock and Live Tests

~ Must {#java-testing-have-mock-and-live-tests}
have a test suite testing functionality at a higher level, in addition to unit tests. These are known as mock and live tests - they are the same test, but mock tests do not require an active service account and can therefore be run by anyone. Live tests are when the mock tests are run against an active service account.

Mock and live tests can be written as long-form unit tests, or else they may be written with other testing / mocking tools, as necessary.
~

~ Must {#java-testing-commit-mocks-to-repo}
provide all necessary mock and live tests as part of the SDK component repository.
~

~ Must {#java-testing-mocks-run-fast}
ensure that all mock tests execute quickly and are integrated into the main unit test suite.
~

~ Must {#java-testing-mocks-give-exec-instructions}
provide instructions as part of your Readme.<span></span>md file to detail how to execute these tests (if different than calling `mvn test`), including any environment variables, running services, etc. Test that these instructions are complete by attempting to run the tests on a separate machine.
~

## Documentation

Quality documentation is often the difference between a productive user experience and a frustrating user experience. There are many aspects to quality documentation, including quickstarts, longer-form tutorials, code samples, and reference documentation. We must ensure that our documentation, in all forms, is of the highest quality. The key criteria in judging our documentation quality is the ease with which a person entirely unfamiliar with our SDK can understand it and become productive - we must have developer empathy.

Documentation, depending on its form and its target audience, can live in many places, but we must strive to keep these locations consistent across all services. These will be detailed in the following sections.

### General Advice

~ MustNot {#java-maven-no-dependency-versions-in-docs}
include version details when specifying Maven dependency statements. Always refer the user back to a central document detailing how to use the Azure SDK for Java BOM.
~

~ Todo
Link to central document detailing Azure SDK BOM.
~

### Quickstarts & Tutorials

~ Must {#java-docs-quickstarts}
contribute at least one [quickstart](https://review.docs.microsoft.com/help/contribute/contribute-how-to-mvc-quickstart?branch=master) or [tutorial](https://review.docs.microsoft.com/help/contribute/contribute-how-to-mvc-tutorial?branch=master) (or a brand new document if necessary). This content must be discoverable from the table of contents of [docs.microsoft.com](http://docs.microsoft.com) for [Java](http://docs.microsoft.com/azure/java), but it does not need to be directly linked to from the table of contents.
~

### Code Samples

Code samples are small applications that demonstrate a certain feature that is relevant to the SDK component, allowing developers to more quickly understand the full usage requirements of a particular set of API. Code samples should not be any more complex than they need to be to demonstrate this feature - they should not become full applications. At all times code samples should have a very high signal:noise ratio between useful code and boilerplate code for non-related reasons.

~ Must {#java-samples-location}
place code samples within a `/samples/<sdk component name>` directory within the root directory of the GitHub repo. This directory should itself be a fully-fledged Maven project and buildable using `mvn clean compile`.
~

~ Must {#java-samples-execution}
ensure that each sample file is executable by including a `public static void main(String[] args)` method.
~

~ Must {#java-samples-use-latest-conventions}
use the latest coding conventions when creating samples. It is recommended to make liberal use of modern Java syntax and API such as diamond operators, etc as they remove boilerplate from your samples and let your library's API shine through better. Do not use any language feature or API of Java beyond the current Java baseline versioned employed by the SDK, currently this is JDK 8.
~

~ Must {#java-samples-maintained}
keep sample code maintained and using the latest major release of the library. Sample code repos must be reviewed for freshness and at least one commit must be made to a sample repo every semester - at least to update dependencies to the latest release and to ensure that the code continues to function as expected.
~

~ Must {#java-samples-easy-grafting}
ensure that sample code snippets in quickstarts and tutorials can be easily grafted from the documentation into a users own application and not tied to variable declarations not covered in previous snippets in the content.
~

~ Must {#java-samples-keep-simple}
ensure that code snippets are optimized for ease of reading and comprehension over code compactness and efficiency unless the article context demands otherwise.
~

~ Must {#java-samples-cross-platform}
ensure that samples can run in Windows, macOS, and Linux development environments, and are not tied to a non-standard developer toolchain.
~

~ Must {#java-samples-minimal-readme-content}
keep code samples displayed in the GitHub README<span></span>.md file to a minimum, with preference being to link people to appropriate resources rather than to overwhelm the readme file. A minimal set of critical code samples should however be included as part of the readme file.
~

~ Must {#java-samples-link-from-readme}
place links in the GitHub documentation for the SDK component, under "Code Samples" in the "Samples" section of the ToC, to the [Azure Samples Gallery](https://azure.microsoft.com/resources/samples/) or to a curated page in your documentation set that lists the samples available for your service.
~

~ Note {#java-link-to-docsmsft}
At all times we should consciously ensure that we link back to docs.microsoft.com whenever relevant. Sample repos provided by the service and docs team must link back to the service on docs.microsoft.com and the reference overview page for the library.
~

### JavaDoc

JavaDoc ships with a [number of tags](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html#CHDJFCCC) such as `@link`, `@param`, and `@return`, which provide more context to the JavaDoc tooling, and which therefore enables a richer experience when HTML output is generated. It is extremely useful when writing JavaDoc content to keep these in the back of your mind, to ensure that they are all used when relevant. To understand when to use each of these tags, refer to the ['Tag Comments' section](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html#CHDJFCCC) of the Java Platform, Standard Edition Tools Reference documentation.

~ Must {#java-javadoc-use-tags}
annotate your source code with JavaDoc declarations.
~

~ Must {#java-javadoc-specify-api}
use JavaDoc as the specification of the API. Engineers responsible for writing API must consider it part of their job to ensure that a JavaDoc is complete, with class-level and method-level overviews for all public and protected API, specifying the expected inputs, outputs, exceptional circumstances, and any other detail.
~

~ Must {#java-javadoc-easy-generation}
ensure that anybody can clone the repo containing the SDK component and execute `mvn javadoc:javadoc` to generate the full and complete JavaDoc output for the code, without any need for additional processing steps.
~

~ Must {#java-javadoc-include-samples}
include code snippets in the JavaDoc content that users can copy/paste into their own software to kick start their own development. These code snippets need not be long screeds of code - it is best if they are constrained to no more than five to ten lines of code. These code snippets can be added to the JavaDoc of the relevant class or method over time, as users start to ask questions on the API.
~

~ Must {#java-javadoc-check-for-leaks}
use JavaDoc to ensure that no implementation details leak out of public API. Developers must ensure that implementation classes are not visible in any public API as method parameters or return types. Similarly, only approved external dependencies should be visible as public API. Finally, JavaDoc must be inspected for completeness and accuracy.
~

#### JavaDoc for Behavioral Contracts

One underutilised aspect of JavaDoc is to use it to specify behavioral contracts. An example of a behavioral contract is the `Arrays.sort()` method, which guarantees it is 'stable' (that is, equal elements are not reordered). There is no way to easily specify this guarantee as part of the API itself (aside from making our API unwieldy, e.g. `Arrays.stableSort()`), but JavaDoc is an ideal location for this.

However, if we add behavioral contracts as part of our JavaDoc, this then becomes as much a part of our API as the API itself. We can not change this behavioral contract with the same level of consideration, as it will potentially cause downstream issues for your users.

### Reference Overview

~ Must {#java-reference-overview}
have a Java [reference overview page](https://review.docs.microsoft.com/help/contribute/contribute-reference-overviews?branch=master) for the client library under the Reference node in your content's ToC with a specific Java entry in that ToC. This reference overview must live in either the Java Azure SDK reference repo or in your own content set alongside the rest of your docs.
~

~ Must {#java-reference-link-to-quickstart}
link the reference overview page to the quickstart and available samples for the audience.
~