## Java API specifics {#java-api-shape}

### Async API

~ Must {#java-async-client}
offer an async service client named `<ServiceName>AsyncClient`. More than one service client may be offered for a single service.
~

~ Must {#java-async-use-project-reactor}
use [Project Reactor](http://projectreactor.io) to provide end-users with a high-quality async API.
~

~ MustNot {#java-async-no-other-libs}
use any other async APIs, such as `CompletableFuture` and [RxJava](https://github.com/ReactiveX/RxJava).
~

~ MustNot {#java-no-async-naming-pattern}
use the suffix `Async` in methods that perform operations asynchronously. Let the fact the user has an instance of an 'async client' provide this context.
~

~ MustNot {#java-async-no-overloads}
provide multiple asynchronous methods for a single REST endpoint, unless to provide overloaded methods to enable alternative or optional method parameters.
~

~ MustNot {#java-async-cancellations}
provide API that accepts a cancellation token. Cancellation is not a common pattern in Java, and developers who want to be able to cancel requests will be encouraged to use the ability to unsubscribe from a publisher to effect this request.
~

~ MustNot {#java-async-no-custom-API}
write custom APIs for streaming or async operations - make use of the existing functionality offered in the Azure Java SDK base class library. Where necessary, additional functionality should be introduced into the Azure Java SDK base class library after discussions with the [Java architect](mailto:adparch@microsoft.com).
~

~ MustNot {#java-async-no-blocking}
include blocking calls inside client library code. Code must be async throughout entire codebase. Use [BlockHound](https://github.com/reactor/BlockHound) to detect blocking calls in async APIs.
~

### Sync API

~ Must {#java-sync-client}
offer a sync service client named `<ServiceName>Client`. More than one service client may be offered for a single service.
~

~ MustNot {#java-sync-cancellations}
provide API that accepts a cancellation token. Cancellation is not a common pattern in Java, and developers who want to be able to cancel requests will be encouraged to use the async API instead.
~

### Service Clients

Azure services will be exposed to Java developers as one or more service client types, plus a set of model classes and other supporting types. The guidelines in this section describe patterns for the design of a service clients and their members.

~ Must {#java-client-suffix}
name service client types with the Client suffix, e.g. `ConfigurationClient`.
~

~ Must {#java-client-root-package}
place service clients in the root package of their corresponding client library, e.g. `com.azure.storage.blob.BlobClient`, as `com.azure.storage.blob` is considered the root package in this example.
~

~ Must {#java-client-immutable}
ensure that all service client classes are immutable upon instantiation.
~

~ MustNot {#java-client-no-ctor}
provide any `public` or `protected` constructors in the service client, except where necessary to support mock testing. Keep visibility to a minimum.
~

~ Must {#java-sync-client-structure}
follow the basic shape outlined below for all synchronous service clients:

```java
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.azure.<group>.<service_name>;

@ServiceClient(
    builder = <service_name>ClientBuilder.class, 
    serviceInterfaces = <service_name>Service.class)
public final class <service_name>Client {

    // internally, sync API can defer to async API with sync-over-async
    private final <service_name>AsyncClient client;
    
    // package-private constructors only - all instantiation is done with builders
    <service_name>Client(<service_name>AsyncClient client) {
        this.client = client;
    }

    // service methods...

    // A single response API
    public Response<<model>> <service_operation>(<parameters>) {
        // deferring to async client internally
        return client.<service_operation>(<parameters>).block();
    }

    // A non-paginated sync list API (refer to pagination section for more details)
    public Stream<<model>> list<service_operation>(<parameters>) {
        // deferring to async client internally
        return client.list<service_operation>(<parameters>).toStream();
    }

    // other members
    â€¦
}
```

Refer to the [ConfigurationClient class](https://github.com/Azure/azure-sdk-for-java/blob/master/appconfiguration/client/src/main/java/com/azure/data/appconfiguration/ConfigurationClient.java) for a fully built-out example of how a sync client should be constructed.
~

~ Must {#java-async-client-structure}
follow the basic shape outlined below for all asynchronous service clients:

```java
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.azure.<group>.<service_name>;

@ServiceClient(
    builder = <service_name>ClientBuilder.class, 
    serviceInterfaces = <service_name>Service.class,
    isAsync = true)
public final class <service_name>AsyncClient {
        
    // package-private constructors only - all instantiation is done with builders
    <service_name>Client(<parameters>, HttpPipeline pipeline) {
        super(pipeline);
    }

    // service methods...

    // A single response API
    public Mono<Response<<model>>> <service_operation>(<parameters>) {
        ...
    }

    // A paginated response API
    public PagedFlux<<model>> list<service_operation>(<parameters>) {
        ...
    }

    // other members
    ...
}
```

Refer to the [ConfigurationAsyncClient class](https://github.com/Azure/azure-sdk-for-java/blob/master/appconfiguration/client/src/main/java/com/azure/data/appconfiguration/ConfigurationAsyncClient.java) for a fully built-out example of how an async client should be constructed.
~

~ Must {#java-service-client-builder}
offer a fluent builder API for constructing service clients named `<service_name>ClientBuilder`, which must support building a sync service client instance and an async service client instance (where appropriate). It must offer `buildClient()` and `buildAsyncClient()` API to create a synchronous and asynchronous service client instance, respectively:

```java
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.azure.<group>.<service_name>;

public final class <service_name>ClientBuilder {

    // private fields for all settable parameters
    ...

    // public constructor - this is the only available front door to creating a service client instance
    public <service_name>ClientBuilder() {
        builder = <service_name>AsyncClient.builder();
    }

    // The buildClient() method returns a new instance of the sync client each time it is called
    public <service_name>Client buildClient() {
        // create an async client and pass that into the sync client for sync-over-async impl
        return new <service_name>Client(buildAsync());
    }

    // The buildAsyncClient() method returns a new instance of the async client each time it is called
    public <service_name>Client buildAsyncClient() {
        // configuration of pipeline, etc
        ...

        // instantiate new async client instance
        return new <service_name>AsyncClient(serviceEndpoint, pipeline);
    }

    // fluent API, each returning 'this', and one for each parameter to configure
    public <service_name>ClientBuilder <property>(<parameter>) {
        builder.<property>(<parameter>);
        return this;
    }
}
```
~

~ Must {#java-builder-api-consistency}
ensure consistency across all client libraries, by using the following names for client builder fluent API:

| Name                 | Intent                                                                               |
|----------------------|--------------------------------------------------------------------------------------|
| `addPolicy`          | Adds a policy to the set of existing policies (assumes no custom pipeline is set).   |
| `buildAsyncClient`   | Creates a new **async** client on each call.                                         |
| `buildClient`        | Creates a new **sync** client on each call.                                          |
| `configuration`      | Sets the configuration store that is used during construction of the service client. |
| `credential`         | Sets the credential to use when authenticating HTTP requests.                        |
| `connectionString`   | Sets the connection string to use for. This is less-preferred c.f. a `credential`.   |
| `endpoint`           | URL to send HTTP requests to.                                                        |
| `httpClient`         | Sets the HTTP client to use.                                                         |
| `httpLogDetailLevel` | Sets the logging level for HTTP requests and responses.                              |
| `pipeline`           | Sets the HTTP pipeline to use.                                                       |
| `serviceVersion`     | Specifies the version of the Azure service to use.                                   |

The one exception for consistency is that `endpoint` may be renamed if a more user-friendly name can be justified, e.g. `BlobClientBuilder.blobUrl()`.
~

~ Must {#java-builder-build-consistency}
ensure consistency across all client libraries by having the same order of precedence for builder arguments, if there are scenarios where different configurations are possible. The following list outlines required precedence rules:

1. If the user sets a non-null `pipeline`, all other settings related to construction and configuration of a pipeline are ignored. The provided pipeline is used as-is.
~

~ Must {#java-build-async-validation} 
perform all necessary checks to ensure that the builder will instantiate a service client into a valid state as part of the `build*()` calls, if not earlier as part of each fluent property call. Throw relevant exceptions at this point, rather than later, after the client has been instantiated.
~

~ MustNot {#general-apisurface-no-leaking-implementation}
leak the underlying protocol transport implementation details to the consumer.  All types from the protocol transport implementation must be appropriately abstracted.
~

~ Must {#java-naming-subclients}
prefix methods which create or vend sub-clients with `get` and suffix with `Client` or `asyncClient`, for sync and async sub-clients, respectively, e.g. `container.getBlobClient()` or `container.getBlobAsyncClient()`.
~

### Common Service Client Patterns

~ Must {#java-crud-naming}
prefer the use of the following terms for CRUD operations:

|Verb              |Parameters        |Returns                 |Comments                                                                                                                |
|------------------|------------------|------------------------|------------------------------------------------------------------------------------------------------------------------|
| `upsert<noun>`   |key, item         |Updated or created item |Create new item or update existing item. Verb is primarily used in database-like services.                              |
| `set<noun>`      |key, item         |Updated or created item |Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service.            |
| `create<noun>`   |key, item         |Created item            |Create new item. Fails if item already exists.                                                                          |
| `update<noun>`   |key, partial item |Updated item            |Fails if item does not exist.                                                                                           |
| `replace<noun>`  |key, item         |Replace existing item   |Completely replaces an existing item. Fails if the item does not exist.                                                 |
| `delete<noun>`   |key               |Deleted item, or `null` |Delete an existing item. Will succeed even if item did not exist. Deleted item may be returned, if service supports it. |
| `add<noun>`      |index, item       |Added item              |Add item to a collection. Item will be added last, or into the index position specified.                                |
| `get<noun>`      |key               |Item                    |Will return null if item does not exist.                                                                                |
| `list<noun>`     |                  |Items                   |Return list of items. Returns empty list if no items exist.                                                             |
| `<noun>Exists`   |key               |`boolean`               |Return `true` if the item exists.                                                                                       |
~

~ Should {#java-crud-naming-precedence}
remain flexible and use names best suited for developer experience for a particular client library. However, do not let this result in non-Java naming patterns. For example, using `getAll<noun>` instead of `list<noun>` would be frowned upon for a Java client library.
~

### Model classes

Model classes are classes that consumers use to provide required information into client library methods. These typically represent the domain model, or represent options classes that must be configured before the request can be made.

~ Must {#java-model-class-use-ctor}
provide public constructors for all model classes. By default this should be a no-args constructor only, using the fluent setter API to configure the model class. If, however, the model class merits a design where arguments are passed in via the constructor (with or without fluent setters), this is also an acceptable design.
~

~ MustNot {#java-model-class-no-builders}
offer a builder class for model classes.
~

~ Must {#java-model-class-fluent}
provide a fluent API for configuration. Name setter methods simply after the property being set, e.g. `proxy(Proxy p)`, and have all setter methods return `this`.
~

~ Must {#java-model-class-not-immutable}
ensure that fluent setter API return the same instance of the type. Classes using the fluent pattern should not be immutable types.
~

~ MustNot {#java-model-class-no-javabean}
use the JavaBean naming convention of `get*`, `set*`, and `is*`.
~

### Other support classes

For classes that are not client classes or model classes, we choose to not offer builder or fluent APIs. Classes that fall into this category include custom exception types, http policies, credential types, etc.

~ Must {#java-other-class-use-javabean}
use the JavaBean naming convention of `get*`, `set*`, and `is*` for all API.
~

~ MustNot {#java-other-class-no-fluent}
use the fluent API naming convention outlined above for model classes.
~

~ MustNot {#java-other-class-no-builder}
provide a builder class.
~

### Annotations

There are a number of annotations defined in azure-core. Whilst a few of them are used to enable runtime functionality, the bulk of them are used only as part of the [Azure Java SDK code linting tools](#java-tooling) to validate conformance to this spec, and good Java coding practice.

~ Must {#java-use-core-annotations} 
use the azure-core annotations outlined below in all applicable places. Do this eagerly as part of the initial code design, and the code linters will ensure continued conformance to some of the rules outlined in this specification.
~

~ MustNot {#java-annotation-no-string-spacing}
include spaces in annotation string values, unless the description below states it is allowed.
~

The remainder of this section outlines many of the critical annotations that must be used throughout a client library.

#### Service Interface
The first place that a lot of annotations are used is when defining a service interface. A service interface is a Java interface that defines all REST endpoints for a service, but is not part of the public API, as it is hidden behind the service client class itself. For example, here is the service interface for one method within the `ConfigurationService`:

```java
@Host("{url}")
@ServiceInterface("AppConfig")
interface ConfigurationService {
    @Get("kv/{key}")
    @ExpectedResponses({200})
    @UnexpectedResponseExceptionType(code = {404}, value = ResourceNotFoundException.class)
    @UnexpectedResponseExceptionType(HttpResponseException.class)
    Mono<Response<ConfigurationSetting>> getKeyValue(
            @HostParam("url") String url, @PathParam("key") String key, @QueryParam("label") String label,
            @QueryParam("$select") String fields, @HeaderParam("Accept-Datetime") String acceptDatetime,
            @HeaderParam("If-Match") String ifMatch, @HeaderParam("If-None-Match") String ifNoneMatch,
            Context context);
    ...
}
```

There are many annotations to unpack here:

* `@ServiceInterface` specifies that this interface performs the role of representing a REST endpoint for a particular srevice. This string will be used in places such as telemetry and tracing, and therefore must be fit for public consumption. It must be short, alphanumeric only, and without spaces.
* `@Host` is an annotation for parameterizing the host name of a REST service. The `{url}` shown in the annotation above maps with the `@HostParam` annotation on the first argument into the `getKeyValue(..)` method. In other words, when the call is made to `getKeyValue(..)`, the caller provides the url, which is then mapped dynamically into the outgoing call.
* `@Get`, `@Delete`, `@Head`, `@Patch`, `@Post`, and `@Put` all specify the type of HTTP request to perform for a specific method on the interface, as well as the path to the endpoint.
* `@ExpectedResponses` specifies the HTTP status code that this method expects to receive back. There may be more than one valid status code.
* `@UnexpectedResponseExceptionType` enables for different exceptions to be thrown based on the status code returned in the response, as well as a single fall-back exception if no status codes match.
* There are many valid annotation types for method parameters:
   * `@BodyParam` puts the argument into the body of the outgoing HTTP request.
   * `@HeaderParam` puts the argument into the header of the outgoing HTTP request.
   * `@PathParam` puts the argument into the path of the outgoing HTTP request, at the point where the value of the annotation matches the same value in the HTTP request type annotation (i.e. `@Get`, `@Delete`, `@Head`, `@Patch`, `@Post`, or `@Put`).
   * `@QueryParam` puts the argument into the query string of the outgoing HTTP request.

#### Service Client
The next place to include annotations is the service client class itself. In here we make use of the `@ServiceClient` and `@ServiceMethod` annotatations, on the service client class and each service client method that does network IO, respectively. Here is a sample class demonstrating the use of these two annotations:

```java
@ServiceClient(builder = ConfigurationAsyncClientBuilder.class, isAsync = true, service = ConfigurationService.class)
public final class ConfigurationAsyncClient {

    @ServiceMethod
    public Mono<Response<ConfigurationSetting>> addSetting(String key, String value) { 
        ... 
    }
}    
```

* `@ServiceClient` is placed on all classes that provide API to communicate with an Azure service. The annotation supports specifying the builder responsible for instantiating the service client, whether or not the API is asynchronous, and a reference back to the service interface (the interface annotated with `@ServiceInterface`).
* `@ServiceMethod` is placed on all service client methods that perform network operations.

#### Service Client Builder
The `@ServiceClientBuilder` annotation should be placed on any class that is responsible for instantiating service clients (that is, instantiating classes annotated with `@ServiceClient`). For example:

```java
@ServiceClientBuilder(serviceClients = {ConfigurationClient.class, ConfigurationAsyncClient.class})
public final class ConfigurationClientBuilder { ... }
```

As can be seen above, this builder states that it is able to build instances of `ConfigurationClient` and `ConfigurationAsyncClient`.

#### Model Classes
There are two annotations of note that should be applied on model classes, when applicable:

* The `@Fluent` annotation is given to all model classes that are expected to provide a fluent API to end users. If a class has this annotation, checks can be made to ensure all API meets this expectation. Similarly, classes that are not annotated with this annotation should not have fluent APIs.
* The `@Immutable` annotation is given to all immutable classes. If a class has this annotation, checks can be made to ensure all fields in this class are final.

### Versioning {#java-service-versioning}

~ Draft
The API for specifying a specific service version is not yet defined, so this section will change as it becomes more concrete.
~

As opposed to the [release versioning](#sec-versioning) section later in this document, this section details how to provide API to consumers such that they may specify exactly which version of an Azure service they want to use.

~ Must {#java-service-version-default}
call the latest supported service API version by default.
~

~ Must {#java-service-version-option}
allow explicitly selecting a supported service API versions when instantiating service client types as part of the client builder API through the `serviceVersion` API. This method will take a `ServiceVersion` enumeration value. This enumeration must have a `getLatest()` method to return the latest service version. If a consumer does not specify a service version, the builder will call `ServiceVersion.getLatest()` and use this version for the lifetime of that client instance.
~