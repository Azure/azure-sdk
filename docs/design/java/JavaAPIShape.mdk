## Java API specifics {#java-api-shape}

There exists three types of classes in a Java client library: client classes, model classes, and all other classes. Each of these types follow different design patterns, outlined in the sections below.

~ Must {#java-be-idiomatic}
ensure that all APIs are idiomatic for Java developers and follow best practices.
~

### Async API

~ Must {#java-async-methods}
provide asynchronous API.
~

~ Must {#java-async-client}
offer an async service client named `<ServiceName>AsyncClient`. More than one service client may be offered for a single service.
~

~ Must {#java-async-use-project-reactor}
use [Project Reactor](http://projectreactor.io) to provide end-users with a high-quality async API.
~

~ MustNot {#java-async-no-other-libs}
use any other async APIs, such as `CompletableFuture` and [RxJava](https://github.com/ReactiveX/RxJava).
~

~ MustNot {#java-no-async-naming-pattern}
use the suffix `Async` in methods that perform operations asynchronously. Let the fact the user has an instance of an 'async client' provide this context.
~

~ MustNot {#java-async-no-overloads}
provide multiple asynchronous methods for a single REST endpoint, unless to provide overloaded methods to enable alternative or optional method parameters.
~

~ MustNot {#java-async-cancellations}
provide API that accepts a cancellation token. Cancellation is not a common pattern in Java, and developers who want to be able to cancel requests will be encouraged to use the ability to unsubscribe from a publisher to effect this request.
~

~ Must {#java-async-useful-return-type}
ensure that all async methods return a type that contains all information to enable a developer to inspect the metadata related to the service call (e.g. for HTTP endpoints, the async method call must return a type that enables the developer to read the headers, status code, and all other useful information).
~

~ MustNot {#java-async-no-custom-API}
write custom APIs for streaming or async operations - make use of the existing functionality offered in the Azure Java SDK base class library. Where necessary, additional functionality should be introduced into the Azure Java SDK base class library after discussions with the [Java architect](mailto:adparch@microsoft.com).
~

~ MustNot {#java-async-no-blocking}
include blocking calls inside client library code. Code must be async throughout entire codebase. Use [BlockHound](https://github.com/reactor/BlockHound) to detect blocking calls in async APIs.
~

### Sync API

~ Must {#java-sync-methods}
provide synchronous API.
~

~ Must {#java-sync-client}
offer a sync service client named `<ServiceName>Client`. More than one service client may be offered for a single service.
~

~ MustNot {#java-sync-cancellations}
provide API that accepts a cancellation token. Cancellation is not a common pattern in Java, and developers who want to be able to cancel requests will be encouraged to use the async API instead.
~

### Service Clients

Azure services will be exposed to Java developers as one or more service client types, plus a set of model classes and other supporting types. The guidelines in this section describe patterns for the design of a service clients and their members.

~ Must {#java-client-suffix}
name service client types with the Client suffix, e.g. `ConfigurationClient`.
~

~ Must {#java-client-root-package}
place service clients in the root package of their corresponding client library, e.g. `com.azure.storage.blob.BlobClient`, as `com.azure.storage.blob` is considered the root package in this example.
~

~ Must {#java-client-extend-serviceclient}
extend from the `ServiceClient` super class.
~

~ Must {#java-client-immutable}
ensure that all service client classes are immutable upon instantiation.
~

~ MustNot {#java-client-no-ctor}
provide any `public` or `protected` constructors in the service client.
~

~ Must {#java-sync-client-structure}
follow the basic shape outlined below for all synchronous service clients:

```java
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.azure.<group>.<service_name>;

public final class <service_name>Client {

    // internally, sync API can defer to async API with sync-over-async
    private final <service_name>AsyncClient client;
    
    // package-private constructors only - all instantiation is done with builders
    <service_name>Client(<service_name>AsyncClient client) {
        this.client = client;
    }

    // service methods...

    // A single response API
    public Response<<model>> <service_operation>(<parameters>) {
        // deferring to async client internally
        return client.<service_operation>(<parameters>).block();
    }

    // A non-paginated sync list API (refer to pagination section for more details)
    public Iterable<<model>> list<service_operation>(<parameters>) {
        // deferring to async client internally
        return client.list<service_operation>(<parameters>).toIterable();
    }

    // other members
    â€¦
}
```
~

~ Must {#java-async-client-structure}
follow the basic shape outlined below for all asynchronous service clients:

```java
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.azure.<group>.<service_name>;

public final class <service_name>AsyncClient extends ServiceClient {
        
    // package-private constructors only - all instantiation is done with builders
    <service_name>Client(<parameters>, HttpPipeline pipeline) {
        super(pipeline);
    }

    // service methods...

    // A single response API
    public Mono<Response<<model>>> <service_operation>(<parameters>) {
        ...
    }

    // A paginated response API
    public PagedFlux<<model>> list<service_operation>(<parameters>) {
        ...
    }

    // other members
    ...
}
```
~

~ Must {#java-service-client-builder}
offer a fluent builder API for constructing service clients named `<service_name>ClientBuilder`, which must support building a sync service client instance and an async service client instance. It must offer `buildClient()` and `buildAsyncClient()` API to create a synchronous and asynchronous service client instance, respectively:

```java
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.azure.<group>.<service_name>;

public final class <service_name>ClientBuilder {

    // private fields for all settable parameters
    ...

    // public constructor - this is the only available front door to creating a service client instance
    public <service_name>ClientBuilder() {
        builder = <service_name>AsyncClient.builder();
    }

    // The buildClient() method returns a new instance of the sync client each time it is called
    public <service_name>Client buildClient() {
        // create an async client and pass that into the sync client for sync-over-async impl
        return new <service_name>Client(buildAsync());
    }

    // The buildAsyncClient() method returns a new instance of the async client each time it is called
    public <service_name>Client buildAsyncClient() {
        // configuration of pipeline, etc
        ...

        // instantiate new async client instance
        return new <service_name>AsyncClient(serviceEndpoint, pipeline);
    }

    // fluent API, each returning 'this', and one for each parameter to configure
    public <service_name>ClientBuilder <property>(<parameter>) {
        builder.<property>(<parameter>);
        return this;
    }
}
```
~

~ Must {#java-builder-api-consistency}
ensure consistency across all client libraries, by using the following names for client builder API:

| Name                 | Intent                                                                               |
|----------------------|--------------------------------------------------------------------------------------|
| `addPolicy`          | Adds a policy to the set of existing policies (assumes no custom pipeline is set).   |
| `buildAsyncClient`   | Creates a new **async** client on each call.                                         |
| `buildClient`        | Creates a new **sync** client on each call.                                          |
| `configuration`      | Sets the configuration store that is used during construction of the service client. |
| `credential`         | Sets the credential to use when authenticating HTTP requests.                        |
| `endpoint`           | URL to send HTTP requests to.                                                        |
| `httpClient`         | Sets the HTTP client to use.                                                         |
| `httpLogDetailLevel` | Sets the logging level for HTTP requests and responses.                              |
| `pipeline`           | Sets the HTTP pipeline to use.                                                       |
| `serviceVersion`     | Specifies the version of the Azure service to use.                                   |

The one exception for consistency is that `endpoint` may be renamed if a more user-friendly name can be justified, e.g. `BlobClientBuilder.blobUrl()`.
~

~ Must {#java-builder-build-consistency}
ensure consistency across all client libraries by having the same order of precedence for builder arguments, if there are scenarios where different configurations are possible. The following rules outline the currently-known precedence requirements:

1. If the user sets a `pipeline`, all other settings related to construction and configuration of a pipeline are ignored. The provided pipeline is used as-is.
~

~ Must {#java-build-async-validation} 
perform all necessary checks to ensure that the builder will instantiate a service client into a valid state as part of the `build()` call, if not earlier as part of each fluent property call. An example of the `buildAsyncClient()` method of `ConfigurationClientBuilder` is shown below:

```java
public ConfigurationAsyncClient buildAsyncClient() {
    Configuration buildConfiguration = (configuration == null) ? ConfigurationManager.getConfiguration().clone() : configuration;
    ConfigurationClientCredentials configurationCredentials = getConfigurationCredentials(buildConfiguration);
    URL buildServiceEndpoint = getBuildServiceEndpoint(configurationCredentials);

    Objects.requireNonNull(buildServiceEndpoint);

    if (pipeline != null) {
        return new ConfigurationAsyncClient(buildServiceEndpoint, pipeline);
    }

    ConfigurationClientCredentials buildCredentials = (credentials == null) ? configurationCredentials : credentials;
    if (buildCredentials == null) {
        throw new IllegalStateException("'credentials' is required.");
    }

    // Closest to API goes first, closest to wire goes last.
    final List<HttpPipelinePolicy> policies = new ArrayList<>();

    policies.add(new UserAgentPolicy(AzureConfiguration.NAME, AzureConfiguration.VERSION, buildConfiguration));
    policies.add(new RequestIdPolicy());
    policies.add(new AddHeadersPolicy(headers));
    policies.add(new AddDatePolicy());
    policies.add(new ConfigurationCredentialsPolicy(buildCredentials));
    HttpPolicyProviders.addBeforeRetryPolicies(policies);

    policies.add(retryPolicy);

    policies.addAll(this.policies);
    HttpPolicyProviders.addAfterRetryPolicies(policies);
    policies.add(new HttpLoggingPolicy(httpLogDetailLevel));

    HttpPipeline pipeline = HttpPipeline.builder()
        .policies(policies.toArray(new HttpPipelinePolicy[0]))
        .httpClient(httpClient)
        .build();

    return new ConfigurationAsyncClient(buildServiceEndpoint, pipeline);
}
```
~

~ MustNot {#general-apisurface-no-leaking-implementation}
leak the underlying protocol transport implementation details to the consumer.  All types from the protocol transport implementation must be appropriately abstracted.
~

### Common Service Client Patterns

~ Must {#java-crud-naming}
prefer the use of the following terms for CRUD operations:

|Verb              |Parameters        |Returns                 |Comments                                                                                                                |
|------------------|------------------|------------------------|------------------------------------------------------------------------------------------------------------------------|
| `upsert<noun>`   |key, item         |Updated or created item |Create new item or update existing item. Verb is primarily used in database-like services.                              |
| `set<noun>`      |key, item         |Updated or created item |Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service.            |
| `create<noun>`   |key, item         |Created item            |Create new item. Fails if item already exists.                                                                          |
| `update<noun>`   |key, partial item |Updated item            |Fails if item does not exist.                                                                                           |
| `replace<noun>`  |key, item         |Replace existing item   |Completely replaces an existing item. Fails if the item does not exist.                                                 |
| `delete<noun>`   |key               |Deleted item, or `null` |Delete an existing item. Will succeed even if item did not exist. Deleted item may be returned, if service supports it. |
| `add<noun>`      |index, item       |Added item              |Add item to a collection. Item will be added last, or into the index position specified.                                |
| `get<noun>`      |key               |Item                    |Will return null if item does not exist.                                                                                |
| `list<noun>`     |                  |Items                   |Return list of items. Returns empty list if no items exist.                                                             |
| `<noun>Exists`   |key               |`boolean`               |Return `true` if the item exists.                                                                                       |
~

~ Should {#java-crud-naming-precedence}
remain flexible and use names best suited for developer experience for a particular client library. However, do not let this result in non-Java naming patterns. For example, using `getAll<noun>` instead of `list<noun>` would be frowned upon for a Java client library.
~

### Model classes

Model classes are classes that consumers use to provide required information into client library methods. These typically represent the domain model, or represent options classes that must be configured before the request can be made.

~ Must {#java-model-class-use-ctor}
provide public constructors for all model classes. By default this should be a no-args constructor only, using the fluent setter API to configure the model class. If, however, the model class merits a design where arguments are passed in via the constructor (with or without fluent setters), this is also an acceptable design.
~

~ MustNot {#java-model-class-no-builders}
offer a builder class for model classes.
~

~ Must {#java-model-class-fluent}
provide a fluent API for configuration. Name setter methods simply after the property being set, e.g. `proxy(Proxy p)`, and have all setter methods return `this`.
~

~ Must {#java-model-class-not-immutable}
ensure that fluent setter API return the same instance of the type. Classes using the fluent pattern should not be immutable types.
~

~ MustNot {#java-model-class-no-javabean}
use the JavaBean naming convention of `get*`, `set*`, and `is*`.
~

### Other support classes

For classes that are not client classes or model classes, we choose to not offer builder or fluent APIs. Classes that fall into this category include custom exception types, http policies, credential types, etc.

~ Must {#java-other-class-use-javabean}
use the JavaBean naming convention of `get*`, `set*`, and `is*` for all API.
~

~ MustNot {#java-other-class-no-fluent}
use the fluent API naming convention outlined above for model classes.
~

~ MustNot {#java-other-class-no-builder}
provide a builder class.
~

### Annotations

~ Draft
There exist a number of annotations in azure-core, with more being identified and added as necessary. Applying all appropriate annotations enables the richest static code analysis, and also the best runtime experience.
~

~ Todo
List all annotations
~

~ MustNot {#java-annotation-no-string-spacing}
include spaces in annotation String values, unless the description below states it is allowed.
~

~ Todo
Write CheckStyle rules that check these requirements (including no spaces as above).
~

#### @ServiceProxy
The `@ServiceProxy` annotation is ...

#### @ServiceClient
The `@ServiceClient` annotation is ...

#### @Tracing
The `@Tracing` annotation is ...

### Versioning {#java-service-versioning}

~ Draft
The API for specifying a specific service version is not yet defined, so this section will change as it becomes more concrete.
~

As opposed to the [release versioning](#sec-versioning) section later in this document, this section details how to provide API to consumers such that they may specify exactly which version of an Azure service they want to use.

~ Must {#java-service-version-default}
call the latest supported service API version by default.
~

~ Must {#java-service-version-option}
allow explicitly selecting a supported service API versions when instantiating service client types as part of the client builder API through the `serviceVersion` API. This method will take a `ServiceVersion` enumeration value. This enumeration must have a `getLatest()` method to return the latest service version. If a consumer does not specify a service version, the builder will call `ServiceVersion.getLatest()` and use this version for the lifetime of that client instance.
~