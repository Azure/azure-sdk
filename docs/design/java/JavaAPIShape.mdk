## Java API specifics {#java-api-shape}

There exists three types of classes in a Java client library: client classes, model classes, and all other classes. Each of these types follow different design patterns, outlined in the sections below.

~ Must {#java-be-idiomatic}
ensure that all APIs are idiomatic for Java developers and follow best practices.
~

### Async API

~ Must {#java-async-methods}
provide asynchronous API.
~

~ Must {#java-async-client}
offer an async service client named `<ServiceName>AsyncClient`. More than one service client may be offered for a single service.
~

~ Must {#java-async-use-project-reactor}
use [Project Reactor](http://projectreactor.io) to provide end-users with a high-quality async API.
~

~ MustNot {#java-async-no-other-libs}
use any other async APIs, such as `CompletableFuture` and [RxJava](https://github.com/ReactiveX/RxJava).
~

~ MustNot {#java-no-async-naming-pattern}
use the suffix `Async` in methods that perform operations asynchronously. Let the fact the user has an instance of an 'async client' provide this context.
~

~ MustNot {#java-async-no-overloads}
provide multiple asynchronous methods for a single REST endpoint, unless to provide overloaded methods to enable alternative or optional method parameters.
~

~ MustNot {#java-async-cancellations}
provide API that accepts a cancellation token. Cancellation is not a common pattern in Java, and developers who want to be able to cancel requests will be encouraged to use the ability to unsubscribe from a publisher to effect this request.
~

~ Must {#java-async-useful-return-type}
ensure that all async methods return a type that contains all information to enable a developer to inspect the metadata related to the service call (e.g. for HTTP endpoints, the async method call must return a type that enables the developer to read the headers, status code, and all other useful information).
~

~ MustNot {#java-async-no-custom-API}
write custom APIs for streaming or async operations - make use of the existing functionality offered in the Azure Java SDK base class library. Where necessary, additional functionality should be introduced into the Azure Java SDK base class library after discussions with the [Java architect](mailto:adparch@microsoft.com).
~

~ MustNot {#java-async-no-blocking}
include blocking calls inside client library code. Code must be async throughout entire codebase. Use [BlockHound](https://github.com/reactor/BlockHound) to detect blocking calls in async APIs.
~

### Sync API

~ Must {#java-sync-methods}
provide synchronous API.
~

~ Must {#java-sync-client}
offer a sync service client named `<ServiceName>Client`. More than one service client may be offered for a single service.
~

~ MustNot {#java-sync-cancellations}
provide API that accepts a cancellation token. Cancellation is not a common pattern in Java, and developers who want to be able to cancel requests will be encouraged to use the async API instead.
~

### Service Clients

Azure services will be exposed to Java developers as one or more service client types, plus a set of model classes and other supporting types. The guidelines in this section describe patterns for the design of a service clients and their members.

~ Must {#java-client-suffix}
name service client types with the Client suffix, e.g. `ConfigurationClient`.
~

~ Must {#java-client-root-package}
place service clients in the root package of their corresponding client library, e.g. `com.azure.storage.blob.BlobClient`, as `com.azure.storage.blob` is considered the root package in this example.
~

~ Must {#java-client-extend-serviceclient}
extend from the `ServiceClient` super class.
~

~ Must {#java-client-immutable}
ensure that all service client classes are immutable upon instantiation.
~

~ MustNot {#java-client-no-ctor}
provide any `public` or `protected` constructors in the service client.
~

~ Must {#java-sync-client-structure}
follow the basic shape outlined below for all synchronous service clients:

```java
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.azure.<group>.<service_name>;

public final class <service_name>Client {

    // internally, sync API can defer to async API with sync-over-async
    private final <service_name>AsyncClient client;
    
    // package-private constructors only - all instantiation is done with builders
    <service_name>Client(<service_name>AsyncClient client) {
        this.client = client;
    }

    // service methods...

    // A single response API
    public Response<<model>> <service_operation>(<parameters>) {
        // deferring to async client internally
        return client.<service_operation>(<parameters>).block();
    }

    // A paginated response API
    public Iterable<<model>> list<service_operation>(<parameters>) {
        // deferring to async client internally
        return client.list<service_operation>(<parameters>).toIterable();
    }

    // other members
    â€¦
}
```
~

~ Must {#java-async-client-structure}
follow the basic shape outlined below for all asynchronous service clients:

```java
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.azure.<group>.<service_name>;

public final class <service_name>AsyncClient extends ServiceClient {
        
    // package-private constructors only - all instantiation is done with builders
    <service_name>Client(<parameters>, HttpPipeline pipeline) {
        super(pipeline);
    }

    // service methods...

    // A single response API
    public Mono<Response<<model>>> <service_operation>(<parameters>) {
        ...
    }

    // A paginated response API
    public PagedFlux<<model>> list<service_operation>(<parameters>) {
        ...
    }

    // other members
    ...
}
```
~

~ Must {#java-service-client-builder}
offer a fluent builder API for constructing service clients named `<service_name>ClientBuilder`, which must support building a sync service client instance and an async service client instance. It must offer `buildClient()` and `buildAsyncClient()` API to create a synchronous and asynchronous service client instance, respectively:

```java
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.azure.<group>.<service_name>;

public final class <service_name>ClientBuilder {

    // private fields for all settable parameters
    ...

    // public constructor - this is the only available front door to creating a service client instance
    public <service_name>ClientBuilder() {
        builder = <service_name>AsyncClient.builder();
    }

    // The buildClient() method returns a new instance of the sync client each time it is called
    public <service_name>Client buildClient() {
        // create an async client and pass that into the sync client for sync-over-async impl
        return new <service_name>Client(buildAsync());
    }

    // The buildAsyncClient() method returns a new instance of the async client each time it is called
    public <service_name>Client buildAsyncClient() {
        // configuration of pipeline, etc
        ...

        // instantiate new async client instance
        return new <service_name>AsyncClient(serviceEndpoint, pipeline);
    }

    // fluent API, each returning 'this', and one for each parameter to configure
    public <service_name>ClientBuilder <property>(<parameter>) {
        builder.<property>(<parameter>);
        return this;
    }
}
```
~

~ Must {#java-build-async-validation} 
perform all necessary checks to ensure that the builder will instantiate a service client into a valid state as part of the `build()` call, if not earlier as part of each fluent property call. An example of the `buildAsyncClient()` method of `ConfigurationClientBuilder` is shown below:

```java
public ConfigurationAsyncClient buildAsyncClient() {
    Configuration buildConfiguration = (configuration == null) ? ConfigurationManager.getConfiguration().clone() : configuration;
    ConfigurationClientCredentials configurationCredentials = getConfigurationCredentials(buildConfiguration);
    URL buildServiceEndpoint = getBuildServiceEndpoint(configurationCredentials);

    Objects.requireNonNull(buildServiceEndpoint);

    if (pipeline != null) {
        return new ConfigurationAsyncClient(buildServiceEndpoint, pipeline);
    }

    ConfigurationClientCredentials buildCredentials = (credentials == null) ? configurationCredentials : credentials;
    if (buildCredentials == null) {
        throw new IllegalStateException("'credentials' is required.");
    }

    // Closest to API goes first, closest to wire goes last.
    final List<HttpPipelinePolicy> policies = new ArrayList<>();

    policies.add(new UserAgentPolicy(AzureConfiguration.NAME, AzureConfiguration.VERSION, buildConfiguration));
    policies.add(new RequestIdPolicy());
    policies.add(new AddHeadersPolicy(headers));
    policies.add(new AddDatePolicy());
    policies.add(new ConfigurationCredentialsPolicy(buildCredentials));
    HttpPolicyProviders.addBeforeRetryPolicies(policies);

    policies.add(retryPolicy);

    policies.addAll(this.policies);
    HttpPolicyProviders.addAfterRetryPolicies(policies);
    policies.add(new HttpLoggingPolicy(httpLogDetailLevel));

    HttpPipeline pipeline = HttpPipeline.builder()
        .policies(policies.toArray(new HttpPipelinePolicy[0]))
        .httpClient(httpClient)
        .build();

    return new ConfigurationAsyncClient(buildServiceEndpoint, pipeline);
}
```
~

### Common Service Client Patterns

~ Must {#java-crud-naming}
prefer the use of the following terms for CRUD operations:

|Verb              |Parameters        |Returns                 |Comments                                                                                                                |
|------------------|------------------|------------------------|------------------------------------------------------------------------------------------------------------------------|
| `upsert<noun>`   |key, item         |Updated or created item |Create new item or update existing item. Verb is primarily used in database-like services.                              |
| `set<noun>`      |key, item         |Updated or created item |Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service.            |
| `create<noun>`   |key, item         |Created item            |Create new item. Fails if item already exists.                                                                          |
| `update<noun>`   |key, partial item |Updated item            |Fails if item does not exist.                                                                                           |
| `replace<noun>`  |key, item         |Replace existing item   |Completely replaces an existing item. Fails if the item does not exist.                                                 |
| `delete<noun>`   |key               |Deleted item, or `null` |Delete an existing item. Will succeed even if item did not exist. Deleted item may be returned, if service supports it. |
| `add<noun>`      |index, item       |Added item              |Add item to a collection. Item will be added last, or into the index position specified.                                |
| `get<noun>`      |key               |Item                    |Will return null if item does not exist.                                                                                |
| `list<noun>`     |                  |Items                   |Return list of items. Returns empty list if no items exist.                                                             |
| `<noun>Exists`   |key               |`boolean`               |Return `true` if the item exists.                                                                                       |
~

### Model classes

Model classes are classes that consumers use to provide required information into client library methods. These typically represent the domain model, or represent options classes that must be configured before the request can be made.

~ Must {#java-model-class-use-ctor}
provide public constructors for all model classes.
~

~ MustNot {#java-model-class-no-builders}
offer a builder class for model classes.
~

~ Must {#java-model-class-fluent}
provide a fluent API for configuration. Name setter methods simply after the property being set, e.g. `proxy(Proxy p)`, and have all setter methods return `this`.
~

~ Must {#java-model-class-not-immutable}
ensure that fluent setter API return the same instance of the type. Classes using the fluent pattern should not be immutable types.
~

~ MustNot {#java-model-class-no-javabean}
use the JavaBean naming convention of `get*`, `set*`, and `is*`.
~

### Other support classes

For classes that are not client classes or model classes, we choose to not offer builder or fluent APIs. Classes that fall into this category include custom exception types, http policies, credential types, etc.

~ Must {#java-other-class-use-javabean}
use the JavaBean naming convention of `get*`, `set*`, and `is*` for all API.
~

~ MustNot {#java-other-class-no-fluent}
use the fluent API naming convention outlined above for model classes.
~

~ MustNot {#java-other-class-no-builder}
provide a builder class.
~