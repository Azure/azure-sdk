## Coding Conventions

Library APIs must be idiomatic and must follow best practices.


### Modern & Idiomatic JavaScript

~ Must {#ts-use-promises}
  use built-in promises for asynchronous operations. You may provide overloads which take callback. Do not import any promise polyfills or libraries.
~

Promises are a part of JavaScript as of ES6, and ES2016 and later editions added async functions and other features that make working with promises easier. Promises are broadly supported in the ecosystem and in Node since 0.12.

~ Should {#ts-use-async-functions}
  use async functions for implementing asynchronous library APIs.
~

Because async function transpilation is fairly heavy, there are cases where the added code size is undesirable. This is especially true for projects which must support ES5 runtimes without generators as the code to implement generators in ES5 is quite large. That said, async functions drastically improve the readability of complex async code. A middle ground is to use the Promise APIs directly for simple things and use async functions when you need to call async APIs along with control flow constructs like `if` and loops.

~ Must {#ts-use-iterators}
  use Iterators and Async Iterators for sequences and streams of all sorts.
~

Both of these protocols are built into the language (Iterators as of ES6, Async Iterators as of ES2018) and are easy to consume using for-of and for-await-of loops. Libraries should use generators to create iterators and async generators to create async iterators (subject to the same qualifications as async functions). Other "streaming" interfaces may be used where appropriate as long as they are idiomatic. Node streams may be used in node, but should not be polyfilled in the browser.

### TypeScript

~ Must {#ts-use-typescript}
  implement your library in TypeScript.
~

~ Must {#ts-ship-type-declarations}
  include type declarations for your library.
~

TypeScript is very popular in the ecosystem and its static types provide significant benefit for both the library authors and consumers. TypeScript also compiles modern JavaScript language features down to code compatible with much older runtimes.

#### tsconfig.json {#ts-tsconfig.json}

This section covers the contents of your tsconfig.json. After implementing this section, your tsconfig.json should look similar to the following example:

~ Figure {#ts-figure-tsconfig-json; caption: "An example tsconfig.json" }
```javascript
{
  "compilerOptions": {
    "declaration": true,
    "module": "es6",
    "moduleResolution": "node",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "outDir": "./dist-esm",
    "target": "es6",
    "sourceMap": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "importHelpers": true
  },
  "include": ["./src/**/*"],
  "exclude": ["node_modules"]
}
```
~

~ Must {#ts-config-exclude}
  have at least "node_modules" in the `exclude` array. This ensures TypeScript isn't needlessly type checking your dependencies.
~

~ MustNot {#ts-config-lib}
  use the `compilerOptions.lib` field. Built in typescript libraries (e.g. esnext.asynciterable) should be included via reference directives. See also [Microsoft/TypeScript#27416](https://github.com/Microsoft/TypeScript/issues/27416).
~

~ Must {#ts-config-strict}
  set `compilerOptions.strict` to true. The strict flag serves two purposes: itâ€™s a best practice for developers as it provides the best TypeScript experience, and also, strict ensures that your type definitions are maximally pedantic so strict TypeScript consumers get their best experience as well.
~

~ Must {#ts-config-esModuleInterop}
  set `compilerOptions.esModuleInterop` to true.
~

~ Must {#ts-config-allowSyntheticDefaultImports}
  set `compilerOptions.allowSyntheticDefaultImports` to true
~

~ Must {#ts-config-target}
  set `compilerOptions.target`, but it can be any valid value so long as the final source distributions are compatible with the runtimes your library targets. See also [#ts-source-distros].
~

~ Should {#ts-config-isolatedModules}
  set `compilerOptions.isolatedModules` to true. Isolated modules prevent usage of features that prevent compiling TypeScript code on a file-by-file basis. This ensures your code remains maximally interoperable with compilers in the ecosystem (i.e. the Babel plugin).
~

~ Must {#ts-config-forceConsistentCasingInFileNames}
  set `compilerOptions.forceConsistentCasingInFileNames` to true. `forceConsistentCasingInFileNames` forces TypeScript to treat files as case sensitive. This ensures you don't get surprised by build failures when moving between platforms.
~

~ Must {#ts-config-module}
  set `compilerOptions.module` to "es6". Bundlers such as Rollup or Webpack should be used to produce the CommonJS/UMD build. The TypeScript compiler can also produce both source distributions using separate tsconfig files. When using this configuration, use the tsconfig.json's extends field to override module to "commonjs". This configuration is not recommended for large libraries. It is more resource intensive due to type checking your library twice.
~

~ Must {#ts-config-moduleResolution}
 set `compilerOptions.moduleResolution` to "node" if your library targets Node. Otherwise, it should be absent.
~

~ Must {#ts-config-declaration}
  set `compilerOptions.declaration` to true. The `--declaration` option tells TypeScript to emit a `d.ts` file that contains the public surface area of your library. TypeScript and editors use this file to provide intellisense and type checking capabilities. Ensure you reference this type declaration file from the `types` field of your package.json.
~

~ MustNot {#ts-config-no-experimentalDecorators}
  set `compilerOptions.experimentalDecorators` to `true`. The experimentalDecorators flag adds support for "v1 decorators" to TypeScript. Unfortunately the standards process has moved on to a somewhat incompatible second version that is not yet implemented by TypeScript. Taking a dependency on decorators now means signing up your users for potential breakage later. Until decorators become a standard feature, projects must not use decorators.
~

~ Must {#ts-config-sourceMap}
  set `compilerOptions.sourceMap` and `compilerOptions.declarationMap` to true. Shipping source maps in your package ensures clients can easily debug into your library code. `sourceMap` maps your emitted JS source to the declaration file and `declarationMap` maps the declaration file back to the TypeScript source that generated it. Be sure to include your original TypeScript sources in the package.
~

~ Must {#ts-config-importHelpers}
  set `compilerOptions.importHelpers` to true. Using external helpers keeps your package size down. Without this flag, TypeScript will add a helper block to each file that needs it. This results in duplication if multiple files are using the same language features. The file size savings using this option can be huge when using for example async functions in a number of different files.
~

#### TypeScript Coding Guidelines

TypeScript Namespaces should not be used. Namespaces either use the `namespace` keyword explicitly, or the `module` keyword with a module name, e.g. `module Microsoft.ApplicationInsights { ... }`. Use top-level imports/exports with ECMAScript modules instead. Namespaces are a non-standard feature that makes your TypeScript code less compatible with standard ECMAScript and creates significant friction with the rest of the ecosystem.

Avoid using const enums. Const enums require global understanding of your program to compile properly. As a result, const enums can't be used with Babel 7 which otherwise supports TypeScript. Avoiding const enums will make sure your code can be compiled by any tool. Use regular enums instead.

### Typedoc

You must annotate your source code with Typedoc declarations.

Typedoc comments give your users a pleasant tooling experience by pulling in your documentation in parameter help and in other tooling scenarios. [Typedoc tags](http://typedoc.org/guides/doccomments/) are very much inline with [jsdoc tags](http://usejsdoc.org/).

There is a work in progress tool called [tsdoc](https://github.com/Microsoft/tsdoc/) that aims to be the standard way to document TypeScript code. ANPS will migrate to this new documentation format, but in the meantime, the Docs team is set up to ingest only Typedoc, and thus Typedoc is the way to go for now.

## Documentation

Your package's documentation must consist of at least one quickstarts or tutorial in addition to samples, API documentation, and a reference overview. Some content, such as samples, must be included in-repo. Other content may be written externally for example on docs.microsoft.com. The following sections cover this content in more detail.

### Quickstarts &amp; Tutorials

Your package should have at least one [Quickstart](https://review.docs.microsoft.com/en-us/help/contribute/contribute-how-to-mvc-quickstart?branch=master) or [tutorial](https://review.docs.microsoft.com/en-us/help/contribute/contribute-how-to-mvc-tutorial?branch=master). This content must be discoverable from the Table of Contents of docs.microsoft.com for JavaScript or Node.js.

TODO: clarify which (node, js, or both?)

npm install statements for the package should be versionless.

### Code Samples

Your package's documentation must link to "Code Samples" under the "Samples" section of the ToC that links to the [Azure Samples Gallery](https://azure.microsoft.com/en-us/resources/samples/) or to a curated page in your documentation set that lists the samples available for your service.

Samples must use the latest coding conventions. It is recommended to make liberal use of modern JavaScript syntax like arrow functions and async functions as they remove boilerplate from your samples and let your library's API shine through better.

TODO: Should code samples be all TypeScript? Or have at least one TypeScript sample?

Sample repos provided by the service and docs team must link back to the service on docs.microsoft.com and the reference overview page for the library.

Sample code should be maintained and must use the latest major release of the library. Sample code repos should be reviewed for freshness and at least one commit should be made to a sample repo every semester.

Sample code snippets in quickstarts and tutorials should be easily grafted from the documentation into a users own application and not tied to variable declarations not covered in previous snippets in the content.

Code snippets should be optimized for ease of reading and comprehension over code compactness and efficiency unless the article context demands otherwise.

Samples must be runnable on macOS and Linux development environments and not tied to our developer toolchain.

Sample code repos should have clear names, descriptions and README files per the [samples guidance](https://review.docs.microsoft.com/help/contribute/contribute-get-started-azure-samples?branch=master) so that they make sense if accessed outside the context of docs.microsoft.com or the [Azure samples portal](https://azure.microsoft.com/en-us/resources/samples).

### API Documentation

API documentation must be auto-generated from source code annotations.

### Reference Overview

You must have a JavaScript or Node.js [reference overview page](https://review.docs.microsoft.com/en-us/help/contribute/contribute-reference-overviews?branch=master) for the client library under the Reference node in your content's ToC with a specific JavaScript or Node.js entry in that ToC. This reference overview must live in either the JavaScript Azure SDK reference repo or in your own content set alongside the rest of your docs.

The reference overview page must have a link to the quickstart and available samples for the JavaScript audience.

Use [this form](https://aka.ms/publish-on-docs) to on-board new library documentation. See [here](https://review.docs.microsoft.com/en-us/help/onboard/admin/reference/js-ts/road-to-docs?branch=master) for detailed instructions.