## Platform support {#python-scope; @h1-h2: decimal; }

~ Must {#python-version-support}
provide packages supporting Python 2.7.6+ and Python 3.4+
~

~ Must {#python-interpreters}
support PyPy in addition to CPython
~

~ ToDo
fill in
~

## General Python Guidelines

~ Must {#python-zen}
adhere to the [Zen of Python](https://www.python.org/dev/peps/pep-0020/)

  ```
  Beautiful is better than ugly.
  Explicit is better than implicit.
  Simple is better than complex.
  Complex is better than complicated.
  Flat is better than nested.
  Sparse is better than dense.
  Readability counts.
  Special cases aren't special enough to break the rules.
  Although practicality beats purity.
  Errors should never pass silently.
  Unless explicitly silenced.
  In the face of ambiguity, refuse the temptation to guess.
  There should be one-- and preferably only one --obvious way to do it.
  Although that way may not be obvious at first unless you're Dutch.
  Now is better than never.
  Although never is often better than *right* now.
  If the implementation is hard to explain, it's a bad idea.
  If the implementation is easy to explain, it may be a good idea.
  Namespaces are one honking great idea -- let's do more of those!
  ```
~

~ Must {#python-follow-official-general-azure-sdk-guidelines}
follow the general [Azure SDK Design Guidelines](https://azuresdkspecs.z5.web.core.windows.net/) unless explicitly overridden in this document.
~

~ Must {#python-guidelines}
follow the general guidelines in [PEP8](https://www.python.org/dev/peps/pep-0008/t) unless explicitly overridden in this document.
~

~ MustNot {#python-no-borrowing}
"borrow" coding paradigms from other languages.

  *For example, regardless of how common Reactive programming is in the Java community, it is still unfamiliar for most Python developers.*
~

~ Must {#python-consistency}
favor consistency with other Azure Python libraries over other libraries for the same service

  *It is more likely that a developer will use many different libraries using the same language than that a developer will use the same service from many different languages*
~

~ Must {#python-structural-subtyping}
prefer structural subtyping and protocols over explicit type checks.

```python
# Yes
def do_something(thing):
    try:
        something = thing.something()
        ...
    except AttributeError:
        ...


# No
def do_something(thing):
    if isinstance(thing, Thing):
        something = thing.something()
        ...
    else:
        ...
```
~

~ Should {#python-derive-appropriately}
derive from the abstract collections base classes `collections.abc` (or `collections` for Python 2.7).
~

~ Must {#python-type-hints}
provide type hints [PEP484](https://www.python.org/dev/peps/pep-0484/) wherever you are providing class or function documentation.

  - See the [suggested syntax for Python 2.7 and 2.7-3.x straddling code](https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code) for guidance for Python 2.7 compatible code.
~

### Naming

~ Must {#python-snake-case}
use snake_case for variables and method names
  ```python
  # Yes
  service_client = ServiceClient()


  # No
  serviceClient = ServiceClient()
  ```
~

~ Must {#python-pascal-case}
use Pascal case for Types

  ```python
  # Yes
  class ThisIsCorrect(object):
      pass


  # No
  class this_is_not_correct(object):
      pass


  # No
  class camelCasedTypeName(object):
      pass
  ```
~

~ Must {#python-single-underscore}
use a single leading underscore for class, attribute and method names to indicate that a name is not part of the public API and is not guaranteed stable.
~

~ MustNot {#python-no-leading-underscore}
use leading double underscore prefixed method names unless name clashes in inheritence hierarchy are likely. This is rare. 
~

~ Must {#python-use-keyword-parameters-for-flags}
use [keyword arguments](https://docs.python.org/2/tutorial/controlflow.html#keyword-arguments) for optional parameters for code that needs to support Python 2.7 and 3+.
~


~ Must {#python-keyword-args}
use [keyword-only arguments](https://www.python.org/dev/peps/pep-3102/) for known arguments for modules that only need to support Python 3+. You **may** use `**kwargs` to pass through arbitrary arguments to other methods.

  ```python
  # Yes
  def foo(a, *, b=1, c=None):
      pass


  # Yes
  def foo(a, *, b=1, c=None, **kwargs):
      # We don't know the full set of parameters that something_else takes. This is an appropriate use of **kwargs.
      something_else(**kwargs)


  # No
  def foo(a, **kwargs):
      pass
  ```
~


~ Must {#python-parameter-name}
specify the parameter name when calling methods with more than two required positional parameters

  ```python
  def foo(a, b, c):
      pass


  def bar(d, e):
      pass


  # Yes
  foo(a=1, b=2, c=3)
  bar(1, 2)
  bar(e=3, d=4)


  # No
  foo(1, 2, 3)
  ```
~

### Namespaces

~ Must {#python-azure-namespace}
add your code to the 'azure' namespace.
~

~ Must {#python-aio-suffix}
add use the .aio suffix to the namespace for async clients.
~

### Exceptions

~ Must {#python-common-exceptions}
Use the exception types defined in `azure.core.exceptions` for HTTP based services whenever appropriate.
~

~ May
Derive additional exception types from the exceptions defined in azure-core.
~

~ Must {#python-exceptions}
use different derived exception types if the caller is expected to differentiate between failure reasons.

```python
# Yes
try:
    client.do_something_that_will_fail()
except ResourceConflictError as e:
    # Handle some errors here
except ResourceModifiedError as e:
    # Handle other errors here


# No
try:
    client.do_something_that_will_fail()
except SomeAzureException as e:
    if e.status_code == 409:
        # Handle some errors here
    elif e.status_code == 412:
        # Handle other error code here...
    else:
        raise
```

~

~ Must {#python-document-specific-exceptions}
document exceptions explicitly raised by a method. You **should** document other exceptions that may be raised by methods you call.
~

### Cancellations and timeouts

~ Must {#python-timeout-sync-methods}
provide an optional `timeout` parameter for long-running methods. The unit of measure for the value **should** be seconds. If external constraints prevent the use of seconds, the name of the parameter **must** use a suffix to indicate what the unit of measure is. 

```python
# Yes
def do_something_long_running(timeout=-1):
    """
    :param timeout: Raise TimeoutException is operation is not finished within `timeout`s.
    """
    pass


# Yes if required, but avoid if possible
def do_something_even_longer(timeout_milliseconds=-1):
    """
    :param timeout: Raise TimeoutException is operation is not finished within `timeout`ms.
    """
    pass


# No - the unit of measure is incorrect.
def do_something_else(timeout=-1):
    """
    :param timeout: Raise TimeoutException is operation is not finished within `timeout`ms.
    """
    pass
```
~


~ Must {#python-timeout-cancel-async-operations}
cancel any child tasks if asyncio.CancelledError is raised.

ToDo: How to interact with cancellation for Trio and friends
~

### Logging

~ Must {#python-use-logging-module}
use the standard Python [logging module](https://docs.python.org/3.7/library/logging.html).
~

~ Must {#python-provide-logger}
provide a named logger for all packages. The name of the logger **should** use the module name as the name. Sub-packages **should** provide their own logger.
~

~ Must {#python-follow-general-guidelines}
follow the [general logging guidelines](#general-logging) regarding log levels, what to include in a log etc. The terminology used in the general guidelines map to the following log levels 

|Generic name|Python specific name|
|-|-|
|Verbose|Debug
|Informational|Info|
|Warning|Warning|
|Error|Error|
~

### Threading

~ Must {#python-thread-affinity}
maintain thread affinity for user-provided code unless explicitly documented to not do so.
~

~ Must {#python-thread-safe-document}
document any code that is intended to be thread safe.
~

~ MustNot {#python-background-threads}
start threads that prevent an application from being shut down gracefully.

*Note: if ambient background threads are absolutely required, they can be marked as [`daemon`](https://docs.python.org/3.7/library/threading.html#threading.Thread.daemon) threads to allow the process to be terminated even if they are still running.*
~

### Use Azure-Core

~ Must {#pyton-use-http-pipeline}
use the HTTP pipeline defined in azure-core for services calling HTTP endpoints.
~

~ Must {#python-use-base-classes}
use the base classes in [azure-core](https://github.com/Azure/azure-sdk-for-python/tree/master/azure-core) whenever possible:

  |Type|Usage|
  |-|-|
  |`azure.core.Paged`|Base class for return values for service methods that return lists of object. Also supports server driven paging|
  |`azure.core.polling.LROPoller`|Base class for return values for service methods that are long running.|
~

~ Should {#python-pipeline-provide-policies}
provide pipeline policies and corresponding configuration settings allowing application developers to 
~

~ Todo
Provide common policies in previous statement
~

## Service clients

### Client construction {#python-client-construction; @h1-h2-h3-h4: decimal; }

~ Must {#python-client-suffix}
use the suffix "Client" for types accessing the service (Ex. CosmosClient)

```python
class ExampleServiceClient(object):
    pass
```
~

~ Must {#python-client-constructor}
provide a constructor that, in addition to keyword arguments, takes a `credentials` and [`configuration`](#python-service-configuration-object) parameter along with any other arguments needed to construct the client.

The configuration object **must** be optional, and it **must** accept the value provided by the [create_config](#python-client-constructor-get-configuration) method.
~


~ Must {#python-client-constructor-connectionstring-factory}
use a static factory method `from_connection_string` to construct a client instance from a connection string if the service provides connection strings.


The set of accepted `**kwargs` **must** be the same as for the constructor minus any settings provided in the connection string itself.
~

~ Must {#python-client-constructor-get-configuration}
provide a `create_config` method that, given `**kwargs` constructs a [`configuration`](#python-service-configuration-object) object. The set of `**kwargs` accepted **must** be the same as the set accepted by the `__init__` method.
~

-----
Canonical service client implementation:
```python
class ExampleServiceClient(object):
    
    def __init__(self, endpoint=None, credentials=None, configuration=None, **kwargs):
        # type: (str, Credentials, ExampleServiceClientConfiguration, Dict[str, Any])
        pass


    @staticmethod
    def from_connection_string(connection_string, **kwargs):
        # type: (str) -> ExampleServiceClient
        pass


    def get_configuration(self, **kwargs):
        # type: (Dict[str, Any]) -> ExampleServiceClientConfiguration
```
-----
### Configuration object {#python-service-configuration-object}

### Service operations {#python-service-operations}

~ Should {#python-crud-naming}
prefer the use of the following terms for CRUD operations:

|Verb|Parameters|Returns|Comments|
|-|-|-|-|
| upsert_\<noun>|key, item|Updated or created item|Create new item or update existing item. Verb is primarily used in database-like services. |
| set_\<noun>|key, item|Updated or created item|Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service. |
| create_\<noun>|key, item|Created item|Create new item. Fails if item already exists. |
| update_\<noun>|key, partial item|Updated item|Fails if item does not exist. |
| replace_\<noun>|key, item|Replace existing item|Completely replaces an existing item. Fails if the item does not exist. |
| delete_\<noun>|key|None|Delete an existing item. Will succeed even if item did not exist. |
| append_\<noun>|item|Appended item|Add item to a collection. Item will be added last. |
| add_\<noun>|index, item|Added item|Add item to a collection. Item will be added on the given index. |
| remove_\<noun>|key|None or removed item|Remove item from a collection. |
| get_\<noun>|key|Item|Will return None if item does not exist |
| list_\<noun>||`azure.core.Pageable[Item]`|Return list of items. Returns empty list if no items exist |
| \<noun>\_exists|key|`bool`|Return True if the item exists. |
~

~ Must {#python-response-format}
return a value corresponding to the logical value the caller requested rather than a raw HTTP response.

*If the library method is get_thing, the response should be a Thing, not a response that has HTTP status, headers and body properties.*
~

~ Must {#python-response-request-handler-callable}
take a `callable` parameter named `raw_response_hook` that will get called with the raw (non-deserialized) HTTP response value for each outgoing request.
~

~ Must {#python-iterators}
provide iterators over paged results which handle subsequent calls transparently. 

*`azure.core.Paged` is the preferred base class to provide this functionality.*
~

~ Must {#python-follow-azure-python-polling-protocol-arguments}
accept an optional argument `polling` that takes a `azure.core.polling.PollingMethod`-like object.

If a `azure.core.polling.PollingMethod`-like object is provided, it **must** be used by the returned `azure.core.polling.LROPoller`-like object to handle the actual polling.
~

~ Must {#python-follow-azure-python-polling-protocol-return-value}
return a `azure.core.polling.LROPoller`-like object for long running operations.
~

~ Must {#python-auto-poll}
provide a way to automatically poll on long running operations. If the `LROPoller` contract is followed, this is accomplished by calling `result()` on the instance.
~

~ Must {#python-manual-poll}
provide a way to manually poll on long running operations by returning an operations object. The `LROPoller` allows a caller to check the value of `done()` to determine if the polling operation is completed.

  *Starting operation in process 1, handing off the info needed to poll to process 2 is a common pattern in distributed computing.*
~

~ Must {#python-long-op-naming}
prefer the use of the following terms for long running operations:

  - `begin_<verb>_<noun>` for methods returning an operation object
~

~ MustNot {#python-parameter-validation}
Unnecessarily validate type and value for each method or function parameter. Parameter validation **should** be used where raised errors or behavior would otherwise be confusing.

```python
# Yes
def normal_method(name, price):
    if price <= 0:
        raise ValueError('Price must be a positive number')
    return Order(name, price * quantity)


# No
def overly_paranoid_method(name, price):
    if not isinstance(name, str):
        raise TypeError('name must be a string')
    if not name:
        raise ValueError('name must not be empty')
    if not isinstance(price, numbers.Number):
        raise TypeError('price must be a Number')
    if price <= 0:
        raise ValueError('price must be greter than zero')
    return Order(name, price * quantity)
```
~

~ Must {#python-azure-client-per-request-property-override}
provide keyword or keyword-only arguments to override request options such as request timeout on a per-call basis. The name of the argument should match the name of the option set when creating the client.
~


## Dependencies

~ Should {#python-dependency-compat}
use the following packages for shared functionality:

  - six (python 2 and 3 compatibility)
  - requests (synchronous HTTP)
  - aiohttp (asynchronous HTTP)
~

~ MustNot {#python-no-ext-deps}
use external dependencies outside the list of "well known dependencies". To get a new dependency added, contact @adparch. 
~

~ MustNot {#python-no-vendor-deps}
vendor dependencies unless approved by @adparch. Vendoring can sometimes be preferred over taking a dependency of an external package. @adparch can help determine if this is appropriate.

*Vendoring dependencies in Python means including the source from another package as if it was part of your package*
~

## Project structure

~ Must {#python-project-structure}
use the [canonical project structure](https://github.com/Azure/azure-sdk/blob/master/docs/engineering-system/repo-structure.md) for azure python libraries.
~

## Modules and packages

~ Must {#python-modules-dunderall}
Specify which APIs are intended to be publicly accessible from the package by adding them to `__all__` in the packages `__init__.py` file. APIs **may** be added to the `__all__` of subpackages if such a grouping makes conceptual sense.
~

## Packaging

~ Must {#python-wheels}
provide wheels for all supported Python versions and architectures.
~

~ Must {#python-publish-pypi}
publish your packages to PyPI.
~

~ Must {#python-package-naming}
name your package after the namespace of your main client class
~

~ Must {#python-lowercase-packages}
use all lowercase in your package name with a dash (-) as a separator.
~

~ MustNot {#python-no-underscore-or-period}
use underscore (_) or period (.) in your package name. 
~

~ Must {#python-semver}
use semantic versioning for distribution packages.
~

~ Must {#python-follow-packaging-guidance}
follow the specific package guidance from the [azure-sdk-packaging wiki](https://github.com/Azure/azure-sdk-for-python/wiki/Azure-packaging)
~

~ Must {#python-use-pkgutil}
use pkgutil style namespace packages
~

~ Must {#python-use-azure-nspkg}
depend on azure-nspkg for Python 2.x
~

~ Must {#python-follow-pep420}
follow [PEP420](https://www.python.org/dev/peps/pep-0420/) for Python 3.0
~

~ Must {#python-include-init}
include __init__.py for the namespace(s) in sdists
~

### Binary extensions

~ Must {#python-support-operating-systems}
be approved by @adparch
~

~ Must {#python-support-operating-systems}
support Windows, Linux (manylinux - see PEP513), macOS
~

~ Must {#python-support-platforms}
support x86, x64
~

~ Must {#python-support-unicode-ascii}
support unicode and ascii versions of CPython 2.7
~

## Async support

~ Must {#python-sync-apis}
provide sync versions of your APIs. 
~

~ Should {#python-sync-and-async}
provide async versions of your APIs. 
~

~ Must {#python-use-async-await}
use the async/await keywords (requires Python 3.5+)
~

~ MustNot {#python-no-yield}
use the [yield from coroutine/@asyncio.coroutine](https://docs.python.org/3.4/library/asyncio-task.html) syntax in order to support Python 3.4.
~

~ Should {#python-async-package}
ship a separate package for async support if the async version requires additional dependencies.
~

~ Must {#python-async-namespace}
use the same namespace as the synchronous version of the package with .aio appended.
~

~ Must {#python-async-naming}
use the same name of the package as the synchronous version of the package with -aio appended.
~

~ Must {#python-use-same-client-async}
use the same client name for sync and async packages

Example:

|Sync/async|Namespace|Package name|Client name|
|-|-|-|-|
|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|
|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|
~

~ Must {#python-use-aiohttp}
use [aiohttp](https://aiohttp.readthedocs.io/en/stable/) as the default HTTP stack for async operations.
~

~ Should {#python-support-other-async}
support async frameworks other than asyncio (i.e. [Trio](https://trio.readthedocs.io/en/latest/))
~

## Testing

~ Must {#python-use-pytest}
use [pytest](https://docs.pytest.org/en/latest/) as the test framework.
~

~ Should {#python-use-pytest-asyncio}
use [pytest-asyncio](https://github.com/pytest-dev/pytest-asyncio) for testing of async code. 
~

~ Must {#python-test-live-service}
make your scenario tests runnable against live services. Strongly consider using the (Python Azure-DevTools)[https://github.com/Azure/azure-python-devtools] package for scenario tests.
~

~ Must {#python-test-recordings}
provide recordings to allow running tests offline/without an Azure subscription
~

~ Must {#python-simultanous-tests}
support multiple simultanous test runs in the same subscription
~

~ Must {#python-independent-tests}
make each test case independent of other tests
~

## Tooling

~ Must {#python-use-pylint}
use [pylint](https://www.pylint.org/) for your code. Use the pylintrc file in the [root of the repository](https://github.com/Azure/azure-sdk-for-python/blob/master/pylintrc).
~

~ Must {#python-use-flake8}
use [flake8-docstrings](https://gitlab.com/pycqa/flake8-docstrings) to verify doccomments. 
~

~ Must {#python-use-black}
use [Black](https://black.readthedocs.io/en/stable/) for formatting your code.
~

~ Should {#python-use-mypy}
use [MyPy](https://mypy.readthedocs.io/en/latest/) to statically check your code
~

## Documenting your code

~ Must {#python-follow-pydocs}
follow the guidelines in https://aka.ms/pydocs unless explicitly overridden in this document.
~

~ Must {#python-docstring}
use the Azure docstring guidelines to document your code
~

~ Must {#python-code-snippets}
provide code snippets for each non-trivial method
~

~ Must {#python-document-exceptions}
document exceptions that may be raised
~

~ Must {#python-document-loggers}
document any named loggers provided by the package.
~

## Samples

~ Must {#python-samples}
provide samples showing real-world usage of the package

  - Error handling
~