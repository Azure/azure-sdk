The following document describes .NET specific guidelines for designing Azure SDK client libraries. These guidelines complement general [.NET Framework Design Guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/) with design considerations specific to the Azure SDK. Also, these guidelines expand on, and simplify, language-independent [General Azure SDK Guidelines](https://azuresdkspecs.z5.web.core.windows.net). Note that these more specific guidelines take precedence over more general guidelines.

Currently, the document describes guidelines for client libraries exposing HTTP/REST services. It might be expanded in the future to cover other, non-REST, services. 

To illustrate various design concepts, we will be using our showcase component: the client library for the Azure Application Configuration service. You can find this component [here](https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/appconfiguration/Azure.ApplicationModel.Configuration). The library can serve as an illustration of what we expect a great Azure SDK component to look like.

## Design Principles {#dotnet-principles}

Productivity is the main value proposition of the Azure SDK. 
Other qualities, such as completeness, extensibility, performance, and others are important, but secondary. 
We will ensure our customers can be highly productive when using our libraries by ensuring these libraries are:

**Idiomatic**

* Azure SDK libraries follow .NET Framework Design Guidelines.
* Azure SDK libraries feel like designed by the designers of the .NET Standard libraries.
* Azure SDK libraries version just like the .NET Standard libraries. 

> We are not trying to fix bad parts of the language ecosystem; we embrace the ecosystem with its strengths and its flaws.

**Consistent** 

* The Azure SDK feels like a single product of a single team, not a set of NuGet packages.
* Users learn common concepts once; apply the knowledge across all SDK components.
* All differences from the usual must have very good reasons.

**Approachable** 

* Small number of steps to get off the ground; power knobs for advanced users
* Small number of concepts; small number of types; small number of members
* Approachable by our users, not by engineers designing the SDK components
* Easy to find great _getting started_ guides and samples
* Easy to acquire

**Dependable**

* 100% backward compatible
* Great logging, tracing, and error messages
* Predictable support lifecycle, feature coverage, and quality

## General Guidelines {#dotnet-general}

~ Must {#dotnet-follow-official-framework-guidelines}
follow the official .NET [Framework Design Guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/). 

At the end of this document, you can find a section with [the most commonly overlooked guidelines](#dotnet-appendix-overlookedguidelines) in existing Azure SDK libraries.
~

~ Must {#dotnet-follow-official-general-azure-sdk-guidelines}
follow the general [Azure SDK Design Guidelines](https://azuresdkspecs.z5.web.core.windows.net).

These guidelines prescribe many requirements related to telemetry, logging, retry semantics, configuration, proxy settings, extensibility, and others. The easiest way to ensure that your component meets these requirements is to use the [Azure.Core](https://www.nuget.org/packages/Azure.Core/) package to implement all methods that call Azure services. The package contains helper APIs that ensure compliance with these general requirements automatically. Details of these helper APIs and their usage are described in the [Using HttpPipeline](#dotnet-usage-httppipeline) section.
~

~ Must {#dotnet-use-azure-pipeline}
use `HttpPipeline` to implement all methods that call Azure REST services. 

The pipeline can be found in the [Azure.Core](https://www.nuget.org/packages/Azure.Core/) package, and it takes care of many general [Azure SDK Design Guidelines](#common-general), e.g. telemetry, logging, retries, mockability. Details of the pipeline design and usage are described in section [Using HttpPipeline](#dotnet-usage-httppipeline) below.

If for some reason you cannot use the pipeline, you must implement all the general requirements of Azure SDK manually. You can find the requirements described [here](https://azuresdkspecs.z5.web.core.windows.net/)
~

# API Design {#dotnet-api}

## Service Client Design {#dotnet-client}

Azure services will be exposed to .NET developers as one or more _service client_ types, and a set of _supporting types_. The guidelines in this section describe patterns for the design of a service clients and their members.

The basic shape of a service client has the following elements:

```csharp
namespace Azure.<group>.<service_name> {

    // main service client class
    public class <service_name>Client {

        // simple constructors; don't use default parameters
        public <service_name>Client(<simple_binding_parameters>);
        public <service_name>Client(<simple_binding_parameters>, <service_name>ClientOptions options);
        
        // 0 or more advanced constructors
        public <service_name>Client(<advanced_binding_parameters>, <service_name>ClientOptions options = default);

        // mocking constructor
        protected <service_name>Client();

        // service methods (synchronous and asynchronous)
        public virtual Task<Response<<model>> <service_operation>Async(<parameters>, CancellationToken cancellationToken = default);
        public virtual Response<model> <service_operation>(<parameters>, CancellationToken cancellationToken = default);

        // other members
        …
    }

    // options for configuring the client
    public class <service_name>ClientOptions : HttpPipelineOptions {

    }
}
```

For example, the Application Configuration Service client looks like the following:

```csharp
namespace Azure.Data.Configuration {

    public class ConfigurationClient {

        public ConfigurationClient(string connectionString);
        public ConfigurationClient(string connectionString, ConfigurationClientOptions options);
        protected ConfigurationClient(); // for mocking

        public virtual Task<Response<<ConfigurationSetting>> GetAsync(string key, CancellationToken cancellationToken = default);
        public virtual Response<ConfigurationSetting> Get(string key, CancellationToken cancellationToken = default);

        // other members
        …
    }

    // options for configuring the client
    public class ConfigurationClientOptions : HttpPipelineOptions {
        ...
    }
}
```

~ Must {#dotnet-client-name}
name service client types with the _Client_ suffix, e.g. ```ConfigurationClient```.
~

~ Must {#dotnet-client-namespace}
place at least one service client in the root namespace of their corresponding component.
~

~ Must {#dotnet-client-class}
make service clients classes (reference types), not structs (value types).
~

~ Must {#dotnet-client-namespace}
see [Namespace Naming](#dotnet-namespace-naming) guidelines for how to choose the namespace for the client types.
~

### Service Client Constructors {#dotnet-client-ctor}

~ Must {#dotnet-client-ctor-simple}
provide a _hello world_ constructor that takes just the parameters required to bind to and authenticate with the service, e.g. a connection string. 

The idea is that it should be very easy to start using the client without extensive customization. See the [Authentication](#dotnet-authentication) section for more details.

```csharp
public class ConfigurationClient {
    public ConfigurationClient(string connectionString); 
}
```
~

~ MustNot {#dotnet-client-ctor-simple-nodefaults}
use default parameters in the _hello world_ constructor.
~

~ Must {#dotnet-client-ctor-overloads}
provide constructor overloads that allows specifying advanced credentials, a custom pipeline, and other service specific configuration, e.g. service API version.

Custom pipeline and client specific configuration are represented by ```options``` parameter. Guidelines for subclassing and using ```HttpPipelineOptions``` can be found in [Extending and Using HttpPipelineOptions](#dotnet-usage-options) section below.

For example, the ```ConfigurationClient``` type and its public constructors look as follows:

```csharp   
public class ConfigurationClient {
    public ConfigurationClient(string connectionString);
    public ConfigurationClient(string connectionString, ConfigurationClientOptions options);   
    public ConfigurationClient(Uri uri, TokenCredential credential, ConfigurationClientOptions options = default);   
}
```
~

~ Must {#dotnet-client-ctor-mocking}
provide protected parameterless constructor for mocking.

```csharp
public class ConfigurationClient {
    protected ConfigurationClient(); 
}
```

See [Supporting Mocking](#dotnet-mocking) for details. 
~

### Service Methods {#dotnet-client-methods}
This section describes guidelines for designing client methods that call service endpoints. 
As a quick illustration, here are the main service call methods in the ConfigurationClient, and farther below detailed guidelines for various elements of the design.

```csharp
public class ConfigurationClient {

    public virtual Task<Response<ConfigurationSetting>> AddAsync(ConfigurationSetting setting, CancellationToken cancellationToken = default);
    public virtual Response<ConfigurationSetting> Add(ConfigurationSetting setting, CancellationToken cancellationToken = default);

    public virtual Task<Response<ConfigurationSetting>> SetAsync(ConfigurationSetting setting, CancellationToken cancellationToken = default);
    public virtual Response<ConfigurationSetting> Set(ConfigurationSetting setting, CancellationToken cancellationToken = default);

    public virtual Task<Response<ConfigurationSetting>> GetAsync(string key, SettingFilter filter = default, CancellationToken cancellationToken = default);
    public virtual Response<ConfigurationSetting> Get(string key, SettingFilter filter = default, CancellationToken cancellationToken = default);

    public virtual Task<Response<ConfigurationSetting>> DeleteAsync(string key, SettingFilter filter = default, CancellationToken cancellationToken = default);
    public virtual Response<ConfigurationSetting> Delete(string key, SettingFilter filter = default, CancellationToken cancellationToken = default);
}
```

~ Must {#dotnet-method-async-and-sync}
provide both asynchronous and synchronous variants for all service methods.
~

~ Must {#dotnet-method-suffix}
ensure that the names of the asynchronous and the synchronous variants differ only by the _Async_ suffix.
~

~ Must {#dotnet-method-cancellation}
ensure all service methods, both asynchronous and synchronous, take an optional ```CancellationToken``` parameter called _cancellationToken_.

The implementation should pass the token to all I/O calls. It should not check the token manually when no I/O is happening.
~

~ Must {#dotnet-method-virtual}
make service methods virtual.

This is to support mocking. See [Supporting Mocking](#dotnet-mocking) for details. 
~

~ Must {#dotnet-method-returntype}
return ```Task<Response<T>>``` or ```ValueTask<Response<T>>``` from asynchronous service methods, and ```Response<T>``` from the synchronous variants, if the method returns some value or content. 

The `T` represents the content of the response and we will refer to it as the service call return type. See [Service Method Return Types](#dotnet-method-return) below on the details for how to design service return types.

Use standard .NET Framework Design Guidelines to choose between ```Task``` and ```ValueTask```.
~

~ Must {#dotnet-method-returntype}
return ```Task<Response>``` or ```ValueTask<Response>``` from asynchronous service methods, and ```Response``` from the synchronous variants, if the service method does not return anything.

Use standard .NET Framework Design Guidelines to choose between ```Task``` and ```ValueTask```.
~

~ Must {#dotnet-method-threadsafe}
be thread-safe. All public members of the client type must be safe to call from multiple threads concurrently.
~

### Service Method Return Types {#dotnet-method-return}

As mentioned above, service methods will often return ```Response<T>```. The ```T``` can be either an unstructured payload (bytes of a storage blob) or a _model type_ representing deserialized response content. This section describes guidelines for the design of unstructured return types, _model types_, and all their transitive closure of dependencies (the _model graph_).

~ Must {#dotnet-return-type}
use one of the following return types to represent an unstructured payload:

* ```System.IO.Stream``` - for large payloads
* ```byte[]``` - for small payloads
* ```ReadOnlyMemory<byte>``` - for slices of small payloads
~

~ Must {#dotnet-return-type}
return a _model type_ if the content has a schema and can be deserialized.

For example, the configuration service _model type_ looks like the following:
```csharp
public sealed class ConfigurationSetting : IEquatable<ConfigurationSetting> {

    public ConfigurationSetting(string key, string value, string label = default);
    
    public string ContentType { get; set; }
    public string ETag { get; internal set; }
    public string Key { get; set; }
    public string Label { get; set; }
    public DateTimeOffset LastModified { get; internal set; }
    public bool Locked { get; internal set; }
    public IDictionary<string, string> Tags { get; }
    public string Value { get; set; }

    public bool Equals(ConfigurationSetting other);
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public override bool Equals(object obj);
    [EditorBrowsable(EditorBrowsableState.Never)]
    public override int GetHashCode();
    [EditorBrowsable(EditorBrowsableState.Never)]
    public override string ToString();
}
```
... and is returned form service methods as follows:
```csharp
public class ConfigurationClient {
    public virtual Task<Response<ConfigurationSetting>> GetAsync(...);
    public virtual Response<ConfigurationSetting> Get(...);
    ...
}
```
~

~ Must {#dotnet-model-types_immutable}
ensure model public properties are get-only if they are not intended to be changed by the user.

For example, the ```Locked``` property of ```ConfigurationSetting``` is not intended to be changed by the user and so its setter should be internal,
whereas the ```ContentType``` property is designed to be modified and so it has a public setter.
```csharp
public sealed class ConfigurationSetting : IEquatable<ConfigurationSetting> {

    public string ContentType { get; set; }

    public bool Locked { get; internal set; }
}
```
Note: the internal setter for these get-only properties is there to allow the component to deserialize the model types. 
See more on this in [Serialization](#dotnet-usage-serialization) section below.
~

~ Must {#dotnet-model-struct-class}
ensure model types are structs, if they are small, and classes, if they are large, per .NET Framework Design Guidelines.
~

~ Must {#dotnet-model-interfaces}
implement basic data type interfaces on model types, per .NET Framework Design Guidelines. 
For example, implement ```IEquatable<T>```, ```IComparable<T>```, ```IEnumerable<T>```, etc. if applicable.
~

~ Should {#dotnet-model-editorbrowsable}
apply ```[EditorBrowsable(EditorBrowsableState.Never)]``` attribute to ```Equals(object)``` and ```GetHashCode()``` to hide these methods from intellisense,
if they are not intended to be called directly by the user.

A good rule of thumb for ToString is that if it's not overriden and has the default implementation (which returns the type name), it should be hidden.

For example, ```GetHashCode()``` is almost never called directly, and ```Equals(object)``` is almost never called if a type implements ```IEquatable<T>```.

```csharp
public sealed class ConfigurationSetting : IEquatable<ConfigurationSetting> {
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public override bool Equals(object obj);
    [EditorBrowsable(EditorBrowsableState.Never)]
    public override int GetHashCode();
}
```
~

~ Note {#dotnet-model-types-threadsafe}
Unlike client APIs, model type APIs are not required to be thread-safe, as they are rarely shared between threads.
~

~ Must {#dotnet-model-types_mockable}
Ensure that all model types can be used in mocks. 

In practice, means that you need to provide public APIs to construct _model graphs_. See [Supporting Mocking](#dotnet-mocking) for details. 
~

### Returning Collections {#dotnet-paging}
Many Azure REST APIs return data in batches or pages. In the Azure SDK for .NET, we will expose such APIs as methods return ```IEnumerable<T>``` and ```IAsyncEnumerable<T>```.
For example, the configuration service returns collections of items as follows:

```csharp
public class ConfigurationClient {

    // asynchronous API returning a collection of items
    public virtual IAsyncEnumerable<Response<ConfigurationSetting>> GetAllAsync(...);

    // synchronous variant of the method above
    public virtual IEnumerable<Response<ConfigurationSetting>> GetAll(...);
    ...
}
```

~ Must {#dotnet-paging-returntypes}
use ```IEnumerable<Response<T>>``` and ```IAsyncEnumerable<Response<T>>``` as the return type of service methods returning batches or pages of items.

The ```IAsyncEnumerable<T>``` interface is available in [Microsoft.BCL.AsyncInterfaces](https://www.nuget.org/packages/Microsoft.Bcl.AsyncInterfaces) package. 

The ```Response<T>.Raw``` will most probably contain response content related to several individual items, and it's ok.
~

~ Should {#dotnet-paging-raw}
consider exposing raw paging APIs through custom enumerable types with ```ByPage``` method. 

These APIs should be async only. Synchronous collection APIs should not support paging as it adds complexity to APIs optimized for simplicity.

```csharp
public class <Service>Client {

    public AsyncEnumerator<Item> GetItemsAsync(...);

    public class AsyncEnumerator : IAsyncEnumerator<T> {
        public PageAsyncEnumerator<T> ByPage(string continuationToken = default);
    }
}

// Azure.Core Package
namespace Azure.Core {
    public class  PageAsyncEnumerator : IAsyncEnumerator<Page<T>> {
        public int PageSizeHint { get; set; }
        ... // interface implementations
    }

    public struct Page<T> {
        public string ContinuationToken { get; }
        public T[] Values { get; }
        public Response GetRawResponse();
    }
}
```

~

### Service Method Parameters {#dotnet-parameters} 

#### Parameter Validation
Service methods take two kinds of parameters: _service parameters_ and _client parameters_. _Service parameters_ are directly passed across the wire to the service.  _Client parameters_ are not passed directly to the service, but used within the client library. Examples of client parameters include values that are used to construct a URI, or a file that needs to be uploaded to storage.

~ Must {#dotnet-parameters-validation-client} 
validate client parameters.
~

~ MustNot {#dotnet-parameters-validation-service}
validate service parameters.  

This includes null checks, empty strings, and other common validating conditions. Let the service validate its parameters.
~

~ Must {#dotnet-parameters-validation-errors}
test the developer experience when invalid service parameters are passed in. Ensure clear error messages are generated by the client. If the developer experience is inadequate, work with the service team to correct the problem.
~

### Long Running Operations {#dotnet-longrunning}

Some service operations take a very long time, up to days. Such operations are initiated with one service call, and their progress can be monitored with one or more separate calls. 
We will refer to such service operations as `Long Running Operations` (LRO). This section describes how to expose LRO on service clients.

The basic LRO pattern looks like the following:

```csharp
public class <Service>Client {

    // Operation<T> is a type in Azure.Core
    // Note that LROs are exposed as asynchronous methods only
    public Task<Operation<Model>> Start<OperationName>Async(...);

    // this overload lets users access an existing operation
    public Task<Operation<Model>> Start<OperationName>Async(string operationId);

    // synchronous versions
    public Operation<Model> Start<OperationName>(...);
    public Operation<Model> Start<OperationName>(string operationId);
}

// the following types are in Azure.Core package
public abstract class Operation<T>
{
    // will use cached value withing polling interval
    public ValueTask<Response<OperationStatus>> GetStatusAsync(CancellationToken cancellationToken = default);
    public Response<OperationStatus> GetStatus(CancellationToken cancellationToken = default);

    public ValueTask<Response<T>> WaitAsync(CancellationToken cancellationToken = default);

    public Response GetRawResponse(); 
    public T Value; // throws if CachedStatus != Succeeded
    public OperationStatus CachedStatus;

    public string Id { get; }
    public TimeSpan PollingInterval { get; set; }
}

public enum OperationStatus
{
    Running,
    Succeeded,
    Cancelled,
    Failed,
}
```

Which then can be called as follows

```csharp
var client = new ServiceClient();

// automatic polling
{
    Model value = await client.StartOperationAsync().WaitAsync();
    Console.WriteLine(value);
}

// manual polling
{
    Operation<Model> operation = await client.StartOperationAsync();
    while ((await operation.GetStatusAsync(cancel.Token)) == Status.Running)
    {
        await Task.Delay(1000); // play some elevator music
    }
    Console.WriteLine(operation.Value);
}

// saving operation ID
{
    Operation<Model> operation1 = await client.StartOperationAsync();
    string operationId = operation.Id;

    // two days later
    Operation<Model> operation2 = await client.StartOperationAsync(operationId);
    Model value = await operation2.WaitAsync();
}
```

~~ Must {#dotnet-lro-naming}
name all LRO methods with the `Start` prefix.
~~

~~ Should {#dotnet-lro-getagain}
provide an overload of the LRO taking operationId parameter.

This overload is user to access an in-progress LRO.
~~

### Supporting Mocking {#dotnet-mocking}

Azure SDK APIs must support mocking. Here is an example of how the ```ConfigurationClient``` can be mocked using [Moq](https://github.com/moq/moq4) (a popular .NET mocking library):

```csharp
// Create a mock response
var mockResponse = new Mock<Response>();
// Create a client mock
var mock = new Mock<ConfigurationClient>();
// Setup client method
mock.Setup(c => c.Get("Key", It.IsAny<string>(), It.IsAny<DateTimeOffset>(), It.IsAny<CancellationToken>()))
    .Returns(new Response<ConfigurationSetting>(mockResponse.Object, ConfigurationClientModelFactory.ConfigurationSetting("Key", "Value")));

// Use the client mock
ConfigurationClient client = mock.Object;
ConfigurationSetting setting = client.Get("Key");
Assert.AreEqual("Value", setting.Value);
```

The full sample is located [here](https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/appconfiguration/Azure.ApplicationModel.Configuration/samples/Sample8_MockClient.cs)

~~ Must {#dotnet-mocking-virtual}
make all service methods virtual.
~~

~ Must {#dotnet-mocking-ctor}
provide protected parameterless constructor for mocking.

~~ Must {#dotnet-mocking-modelfactory}
provide factory or builder for constructing model graphs returned from virtual service methods. 

In general, model types should not have public constructors, as instances of the type are typically returned from SDK, as opposed to being constructed by the SDK user, yet mock implementations need to create instances of the model types.

A simple factory should be a static class called ```<service>ModelFactory``` in the same namespace as the model types.

```csharp
public static class ConfigurationModelFactory {
    public static ConfigurationSetting ConfigurationSetting(string key, string value, string label=default, string contentType=default, ETag eTag=default, Nullable<DateTimeOffset> lastModified=default, Nullable<bool> locked=default);
    public static SettingBatch SettingBatch(ConfigurationSetting[] settings, string link, SettingSelector selector);
}
```
~~

### Authentication {#dotnet-authentication}

Service client constructors should take all parameters required to create a functioning client, i.e. after the constructor is called service methods can be called successfully. Typically such parameters will include service endpoint information and everything needed to authenticate with the service. General guidelines for all constructors are described in the section [Service Client Constructors](#dotnet-client-ctor). This section talks about constructor parameters required for authentication.

The general constructor pattern talks about _binding parameters_. 

```csharp
// simple constructors
public <service_name>Client(<simple_binding_parameters>);
public <service_name>Client(<simple_binding_parameters>, <service_name>ClientOptions options);

// 0 or more advanced constructors
public <service_name>Client(<advanced_binding_parameters>, <service_name>ClientOptions options = default);
```

Typically, _binding parameters_ would include a URI to the service endpoint and authorization credentials. For example, the blob service client can be bound using either a connection string (which contains both endpoint inforamtion and credentials), anonymous access using just the endpoint uri, or several overloads that specify the endpoint and various credential types.

```csharp
// hello world constructors using the main authentication method on the service's Azure Portal (typically a connection string)
// we don't want to use default parameters here; all other overloads can use default parameters
public BlobServiceClient(string connectionString) 
public BlobServiceClient(string connectionString, BlobClientOptions options)

// anonymous access
public BlobServiceClient(Uri uri, BlobClientOptions options = default)

// using credential types
public BlobServiceClient(Uri uri, StorageSharedKeyCredential credential, BlobClientOptions options = default)
public BlobServiceClient(Uri uri, TokenCredential credential, BlobClientOptions options = default)
```

~ Should {#dotnet-authentication-credentialtypes}
use credential types provided in the ```Azure.Core``` package.

Currently, Azure.Core has the following reusable credential types:

- TokenCredential
~

~ Must {#dotnet-authentication-rolling}
support rolling over credentials without having to create a new client instance.

In practice this means that the credentials passed to the constructors must be read (e.g. TokenCredential.GetToken called) before every request, not just once in the constructor.
~

~ Must {#dotnet-authentication-custom}
contact *adparch@microsoft.com* if you want to add a new credential type.
~

~ May
offer a way to create credentials from a connection string only if the service  offers a connection string via the Azure portal.

In other words, don't ask users to compose connection strings manually, if they are not available through the Azure Portal. An additional limitation of connection strings is that they are immutable and so it's impossible for a client object to pick up new connection strings when they are rolled over.
~

## General Azure SDK Library Design

### Namespace Naming {#dotnet-namespace-naming}

~ Must {#dotnet-namespace-format}
adhere to the following scheme when choosing a namespace: 

`Azure.<group>.<service>[.<feature>]`. 

For example, `Azure.Storage.Blobs`.
~

~ Must {#dotnet-namespace-format-pre-approved}
use one of the following pre-approved namespace groups:

~ Must {#general-namespace-names}
use the following list as the group of services (if the target language supports namespaces):

- `Azure.AI` for artificial intelligence, including machine learning
- `Azure.Analytics` for client libraries that gather or process analytics data
- `Azure.Core` for general purpose libraries, i.e. not service specific
- `Azure.Data` for client libraries that handle databases or structured data stores
- `Azure.Diagnostics` for client libraries that gather data for diagnostics, including logging
- `Azure.Identity` for authentication and authorization client libraries
- `Azure.Iot` for client libraries dealing with the Internet of Things
- `Azure.Management` for client libraries accessing the control plane (ARM)
- `Azure.Media` for client libraries that deal with audio, video, or mixed reality
- `Azure.Messaging` for client libraries that provide messaging services, such as push notifications or pub-sub.
- `Azure.Search` for search technologies
- `Azure.Security` for client libraries dealing with security
- `Azure.Storage` for client libraries that handle unstructured data

If you think a new group should be added to the list, email *adparch@microsoft.com*.
~

~ Must {#dotnet-namespace-registration}
register all namespaces with *adparch@microsoft.com*,
i.e. send email about your proposed namespaces to this address to start a discussion.
~

~ MustNot {#dotnet-namespace-format-service-name}
place APIs in the second level namespace, i.e. in the ```<group>``` namespace.
~

~ Should {#dotnet-namespace-modeltypes}
consider placing model types in a ```.Models``` subnamespaces, if number of model types is or might be large (5+).

This is to ensure that the types needed to create clients and to call service methods are easy to find in the main namespace. 
~

### Error Reporting {#dotnet-errors}

~ Must {#dotnet-errors-exception}
throw ```ResponseFailedException``` or its subtype when a service method fails with non-success status code. 

The exception is available in ```Azure.Core``` package:
```csharp
public class RequestFailedException : Exception {

    public RequestFailedException(int status, string message);
    public RequestFailedException(int status, string message, Exception innerException);

    public int Status { get; }
}
``` 
~

~ Should {#dotnet-errors-exception}
use ResponseExceptionExtensions to create RequestFailedException instances.

This ensures that the exception's message contains detailed response information.

For example, 
```csharp
if (response.Status != 200) {
    ResponseFailedException e = await response.CreateRequestFailedExceptionAsync(message);
    throw e;
}
```
~

~ MustNot {#dotnet-errors-newexceptions}
introduce new exception types, unless there is a programmatic scenario for handling this new exception differently than the base ```ResponseFailedException``` or one of its existing subtypes.
~

### Logging
Request logging will be done automatically by the ```HttpPipeline```. If a client library wants to do custom logging, the designer of the library must ensure that the logging mechanism is pluggable, just like the pipeline logging mechanism is.

~ Must {#dotnet-logging}
follow [general logging guidelines](https://azuresdkspecs.z5.web.core.windows.net/#general-logging), if logging directly, as opposed to through the HttpPipeline.
~ 

#### Distributed Tracing {#dotnet-distributedtracing}

Guidance coming soon ...

### Packaging {#dotnet-packaging}

~ Must {#dotnet-packaging-nuget}
package all components as NuGet packages. Follow the [.NET packaging guidelines](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/nuget).

If your component builds in the Azure SDK team's main repo, majority of the packaging requirements will be met automatically.
~

~ Must {#dotnet-packaging-nuget-name}
name the package based on the name of the main namespace of the component.
For example, if the component is in ```Azure.Storage.Blobs``` namespaces, the component dll should be called ```Azure.Storage.Blobs.dll```, and the NuGet package should be called ```Azure.Storage.Blobs```.
~

~ Should {#dotnet-packaging-nuget-granularity}
place small related components in similar lifecycle stages (i.e. evolving together) in a single NuGet package.
~

~ Must {#dotnet-packaging-ns}
build all libraries for .NET Standard 2.0.
This can be accomplished by the following target setting in the csproj file:
```
<TargetFramework>netstandard2.0</TargetFramework>
```
~

### Dependendencies {#dotnet-dependencies}

~ Should {#dotnet-dependencies-minimize}
minimize dependencies outside of the .NET Standard and Azure.Core packages.
~

~ MustNot {#dotnet-dependencies-list}
have dependencies on any NuGet packages besides:

* Azure.* packages from the [azure/azure-sdk-for-net](https://github.com/Azure/azure-sdk-for-net) repo
* System.Text.Json
* Microsoft.BCL.AsyncInterfaces 
* packages produced by your own team.

In the past, a very common external dependency was JSON.NET package. To avoid this dependency, 
we recommend [System.Text.Json](https://github.com/dotnet/corefx/tree/master/src/System.Text.Json/source_package) 
package that is now a part of the .NET platform. 
~

~ MustNot {#dotnet-dependencies-public}
publicly expose types from dependencies, unless these types follow guidelines described in this document.
~

### Versioning {#dotnet-versioning}

~ Must {#dotnet-compatibility}
follow same backward compatibility rules as .NET Core, i.e. be 100% backward compatible between versions of packages.
See [.NET Breaking Changes](https://github.com/dotnet/corefx/blob/master/Documentation/coding-guidelines/breaking-change-rules.md) for detailed rules.
~

~ Must {#dotnet-service-version-default}
call the highest supported service API version by default.
~

~ Must {#dotnet-service-version-option}
allow explicitly selecting a supported service API versions when instantiating service client types. 

This should be done using a constructor parameter on the client options type. 

* The parameter must be the first parameter to all constructor overloads.
* The parameter must not be optional, i.e. all constructor overloads must have it.
* The parameter should be defaulted to the latest supported service version.
* The parameter type must be an enum nested in the options type.
* The parameter type must be called ServiceVersion.
* The version enum must have explicity specified values, e.g. ```V2019_05_09 = 0```.

```csharp
public class ConfigurationClientOptions : HttpPipelineOptions {
    
    public ConfigurationClientOptions(ServiceVersion version = ServiceVersion.V2019_05_09)

    public enum ServiceVersion {
        V2019_05_09 = 0,
    }
    ...
}
```
~

~ Must {#dotnet-service-version-option}
not use client constructors without the options parameter when instantiating client types in reusable libraries.

This ensures that the library does not change behavior (service version numbers) without the developer of the library making an explicit decision to do that. Note that this is not a guideline for implementing client libraries (like all the other in this document), but rather a guideline for how to safely use client libraries given the versioning rules specified here. 
~

~ Must {#dotnet-package-sxs}
introduce a new package, with new assembly names, new namespace names, and new type names if you must do an API breaking change. This should happen very rarely, if ever. 

Register all such new packages with *adparch@microsoft.com*,
i.e. send email about your proposed package to this address to start a discussion.
~

~ Must {#dotnet-tester-doer}
use tester-doer .NET pattern or ```Nullable<T>```, if some API is not supported based on proxy configuration, e.g. service API version.

For example, 
```csharp
if (client.CanBatch) {
    Response<SettingBatch> response = await client.GetBatch("some_key*");
    Guid? Guid = response.Result.Guid;
}
else {
    Response<ConfigurationSetting> response1 = await client.GetAsync("some_key1");
    Response<ConfigurationSetting> response2 = await client.GetAsync("some_key2");
    Response<ConfigurationSetting> response3 = await client.GetAsync("some_key3");
    …
}
```
~

#### Version Numbers {#dotnet-versionnumbers}

Consistent version number scheme allows consumers to determine what to expect from a new version of the library. 

~ Must {#dotnet-versionnumbers-scheme}
use _MAJOR_._MINOR_._PATCH_ format for the version of the library dll and the NuGet package.

Use _-preview_._N_ suffix for preview package versions. For example, _1.0.0-preview.2_.
~

~ Must {#dotnet-versionnumbers-bump}
change the version number of the client library when **ANYTHING** changes in the client library.
~

~ Must {#dotnet-versionnumbers-patch}
increment the patch version when fixing a bug.
~

~ MustNot {#dotnet-versionnumbers-no-features-in-patch}
include new APIs in a patch release.
~

~ Must {#dotnet-versionnumbers-adding-features}
increment the major or minor version when adding support for a service API version, or add a new API.
~

~ Should {#dotnet-versionnumbers-major-bump}
increment the major version when making large feature changes.
~

### Documentation {#dotnet-documentation}

~ Must
document every exposed (public or protected) type and member within your library's code.
~

~ Must 
use [C# documentation comments](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/documentation-comments) for reference documentation.
~

See [documentation guidelines](https://azuresdkspecs.z5.web.core.windows.net/#general-documentation) for language independent guidelines for how to provide good documentation.

## Common Type Usage {#dotnet-commontypes}

### HttpPipelineOptions {#dotnet-usage-options}

~ Must {#dotnet-usage-options-name}
name subclasses of ```HttpPipelineOptions``` by adding _Client_ suffix to the name of the client type the options subclass is configuraing.

```csharp
// options for configuring ConfigurationClient
public class ConfigurationClientOptions : HttpPipelineOptions {
    ...
}

public class ConfigurationClient {

    public ConfigurationClient(string connectionString, ConfigurationClientOptions options);
    ...   
}
```

Note, if the options type can be shared by multiple client types, consider naming it with a plural or otherwise more general name, e.g. ```BlobClientsOptions``` can be used by ```BlobClient```, ```BlobContainerClient```, and ```BlobAccountClient```.
~

~ MustNot{#dotnet-usage-options-nodefaultctor}
have a default constructor on the options type. 

Each overload constructor should take at least service verions parameter. See [Versioning](#dotnet-service-version-option) guidelines for details.
~

### HttpPipeline {#dotnet-usage-httppipeline}
The following example shows a typical way of using HttpPipeline to implement service call method.
The HttpPipeline will take care of telemetry, logging, retries, and extensibility required by language-independent Azure SDK Guidelines.

```csharp
public virtual async Task<Response<ConfigurationSetting>> AddAsync(ConfigurationSetting setting, CancellationToken cancellationToken = default)
{
    if (setting == null) throw new ArgumentNullException(nameof(setting));
    ... // validate other preconditions

    // Use HttpPipeline _pipeline filed of the client type to create new HTTP request
    using (Request request = _pipeline.CreateRequest()) {
        
        // specify HTTP request line
        request.Method = PipelineMethod.Put;
        request.UriBuilder = ...; 

        // add headers
        request.Headers.Add(IfNoneMatchWildcard);
        request.Headers.Add(MediaTypeKeyValueApplicationHeader);
        request.Headers.Add(HttpHeader.Common.JsonContentType);
        request.Headers.Add(HttpHeader.Common.CreateContentLength(content.Length));

        // add content
        ReadOnlyMemory<byte> content = Serialize(setting);
        request.Content = HttpPipelineRequestContent.Create(content);

        // send the request
        await Pipeline.SendRequestAsync(request).ConfigureAwait(false);

        // get response
        Response response = message.Response;
        if (response.Status == 200) {
            // deserialize content
            Response<ConfigurationSetting> result = await CreateResponse(response, cancellationToken);
        }
        else throw new ResponseFailedException(response);
    }
}
```

Note, that the example above is illustrating basic pipeline usage. In a real client implementation, you would probably endup with more complete and refactored code. See [configuration client](https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/appconfiguration/Azure.ApplicationModel.Configuration/src/ConfigurationClient.cs#L93) implementation for details.

### HttpPipelinePolicy
_HttpPipelinePolicy_ is the base type of all nodes (plugins) of the _HttpPipeline_. This section describes guidelines for designing such custom policies.

~ Must {#dotnet-policy-threadsafe}
inherit from _HttpPipelinePolicy_, if the policy implementation calls asynchronous APIs.

See an example [here](https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/core/Azure.Core/src/Pipeline/Policies/BearerTokenAuthenticationPolicy.cs).
~

~ Must {#dotnet-policy-threadsafe}
inherit from _SynchronousHttpPipelinePolicy_, if the policy implementation calls only synchronous APIs.

See an example [here](https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/core/Azure.Core/src/Pipeline/Policies/ClientRequestIdPolicy.cs).
~

~ Must {#dotnet-policy-threadsafe}
be thread-safe. The `ProcessAsync` and `Process` methods must be safe to invoke from multiple threads cuncurrently.
~

~ Note {#dotnet-policy-request-response-message-threadsafe}
 `HttpPipelineMessage`, `Request`, and `Response` do not have to be thread-safe.
~

### JSON {#dotnet-usage-json}

We recommend that you use [System.Text.Json](https://www.nuget.org/packages/System.Text.Json) package to write and read JSON content.

~ Should {#dotnet-usage-json-writer}
use Utf8JsonWriter to write JSON payloads

```csharp
var json = new Utf8JsonWriter(writer);
json.WriteStartObject();
json.WriteString("value", setting.Value);
json.WriteString("content_type", setting.ContentType);
json.WriteEndObject();
json.Flush();
written = (int)json.BytesWritten;
```
~

~ Should {#dotnet-usage-json-document}
use JsonDocument to read JSON payloads
```csharp
using (JsonDocument json = await JsonDocument.ParseAsync(content, default, cancellationToken).ConfigureAwait(false))
{
    JsonElement root = json.RootElement;

    var setting = new ConfigurationSetting();

    // required property
    setting.Key = root.GetProperty("key").GetString();

    // optional property
    if (root.TryGetProperty("last_modified", out var lastModified)) {
        if(lastModified.Type == JsonValueType.Null) {
            setting.LastModified = null;
        }
        else {
            setting.LastModified = DateTimeOffset.Parse(lastModified.GetString());
        }
    }
    ...

    return setting;
}
```
~

~ Should {#dotnet-usage-json-reader}
consider using Utf8JsonReader to read JSON payloads

Utf8JsonReader is significantly faster than JsonDocument, but much less convenient.
~

~~ Must {#dotnet-usage-serialization-versions}
make your serialization and deserialization code version resilient.

This means optional JSON properties should be deserialized into nullable model properties.
~~

~ Should {#dotnet-model-type-serialization}
consider deserializing the return type lazily if the type is a large graph containing reference types. 
This allows callers to avoid large number of GC heap allocations. ```Response<T>``` allows for such lazy deserialization. See ```Response<T>``` documentation for how to do it.
~

### Primitive Types

~ Must {#dotnet-usage-etag}
use ```Azure.ETag``` to represent ETags.

The type is located in ```Azure.Core``` package.
~

~ Must {#dotnet-usage-uri}
use ```System.Uri``` to represent URIs.
~

# Repository Guidelines {#dotnet-repository}

~ Must {#dotnet-repository-elements}
have samples, readme, and use prescribed folder structure for your client library.

TODO: link to details.
~

## README {#dotnet-repository-readme}

~ Must {#dotnet-repository}
have a README.md file in the component's root folder. 

An example of a good library README.md file can be found [here](https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/appconfiguration/Azure.ApplicationModel.Configuration/README.md).
~

~ Must {#dotnet-repository-readme}
optimize the main README.md for the users of the client library, not the contributors.

The contributor guide (CONTRIBUTING.md) should be a separate file linked to from the main component README.md. The main README.md should start with a simple overview of the component, followed by a link to the component's NuGet page, followed by the Hello World sample, and finally a list of links to other samples.
~

## Samples {#dotnet-samples}

It is very important that each Azure SDK library has a quick-start guide with code samples available. Developers like to start learning how to use reusable libraries by looking at sample code, not by reading in-depth technology papers.  

~ Must {#dotnet-samples-other}
have usage samples in _samples_ subdirectory of main library directory.

See [Configuration Service samples](https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/appconfiguration/Azure.ApplicationModel.Configuration/samples).
~

~ Must {#dotnet-samples-hello_world}
have a sample file called ```S1_HelloWorld.cs```. All other samples are ordered from simplest to most complex using ```S<number>_``` prefix.

See [Configuration Service Hello World](https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/appconfiguration/Azure.ApplicationModel.Configuration/samples/Sample1_HelloWorld.cs) sample.
~

~ Must {#dotnet-samples-hello_world-sync}
use synchronous APIs in the Hello World sample.

You might want to also add ```S2_HelloWorldAsync.cs``` sample.
~

~ Must {#dotnet-samples}
make sure all the samples build and run as part of the CI process. 
~

# Commonly Overlooked .NET API Design Guidelines {#dotnet-appendix-overlookedguidelines}

Some .NET Design Guidelines have been notoriously overlooked in existing Azure SDKs. This section serves as a way to highlight these guidelines.

~ ShouldNot {#dotnet-numberoftypes}
have many types in the main namespace. Number of types is directly proportional to the perceived complexity of a library.
~

~ MustNot {#dotnet-no-abstractions}
have abstractions (interfaces or abstract classes) unless types both implement and consume them (i.e. you have parameters typed as the abstraction).
~

~ MustNot {#dotnet-no-interfaces-for-abstract-classes}
use interfaces if you can use abstract classes. The only reasons to use an interface are: a) you need to “multiple-inherit”, b) you want structs to implement an abstraction.
~

~ MustNot {#dotnet-no-generic-terms}
use very generic words and terms for type names, e.g. do not use names like “OperationResponse”, “DataCollection” etc.
~

~ ShouldNot {#dotnet-no-unclear-parameter-types}
use parameters types where it’s not clear what valid values are supported, e.g. string parameters are often like that.
~

~ MustNot {#dotnet-no-empty-types}
have empty types (types with no members)
~
