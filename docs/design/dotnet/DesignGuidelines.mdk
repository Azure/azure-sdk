The following sections describe .NET specific design guidelines for Azure SDK APIs. These guidelines complement the general [.NET Framework Design Guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/) with design considerations specific to building Azure SDK components. Also, these guidelines expand on, and simplify, the general Azure SDK guidelines. Note that these more specific guidelines take precedence over the more general guidelines.

Currently, the document describes guidelines for .NET APIs exposing HTTP/REST services. It might be expanded in the future to cover other, non-REST, services. 

To illustrate various design concepts, we will be using Azure Application Configuration service in code examples. You can find sources for this component [here](https://github.com/Azure/azure-sdk-for-net-lab/tree/master/Configuration). The Azure.ApplicationModel.Configuration component can serve as an illustration of what we expect a great Azure SDK component for .NET to look like.

## General .NET API Design

~ Must {#dotnet-follow-official-framework-guidelines}
follow the official [Framework Design Guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/). 

See Appendix A (at the end of this document) for design guidelines that are commonly overlooked in existing Azure SDKs.
~

~ Must {#dotnet-follow-official-general-azure-sdk-guidelines}
follow the general Azure SDK Design Guidelines.

The guidelines prescribe many requirements related to telemetry, logging, retry semantics, extensibility, etc. The easiest way to ensure that your component follows these guidelines is to use the Azure.Core package to implement all methods that call Azure services. The package contains many helper APIs that ensure compliance with telemetry, logging, and retry requirements automatically. Details of the design of these helper APIs and their usage are described in _Using HttpPipeline_ section below.
~

~ Must {#dotnet-use-azure-pipeline}
use Azure.Core.Http.HttpPipeline to implement all methods that call Azure services. 

The pipeline can be found in the Azure.Core package, and it takes care of many [General Azure SDK Guidelines](#common-general), e.g. telemetry, logging, retries, mockability. Details of the pipeline design and usage are described in Appendix B below.
~

## Service Client Design

Azure REST services typically fall into two distinct groups:

- Services operating on hierarchical resources, e.g. Azure Storage. We will call these hierarchical resource services.

- Services implementing primarily stateless (utility) operations or managing non-hierarchical resources, e.g. Application Configuration service. We will call these utility services.

Utility services will be exposed to .NET developers as a single proxy type per service plus a set of supporting types. Hierarchical resource services will be exposed as a set of proxy types in a single package. We will refer to such proxy types as Service Clients.

The guidelines in this section describe patterns for the design of a service clients and their members.

The basic shape of a service client has the following elements:

```csharp
namespace Azure.<group>.<service_name> {

    // main service client class
    public class <service_name>Client {

        // constructors
        public service_name>Client(<binding_parameters>);
        public service_name>Client(<binding_parameters>, <options>, HttpPipeline pipeline = default);

        // service methods
        public Task<Response<<content>> <service_operation>Async(<parameters>, CancellationToken cancellation=null);
    
        // other members
        …
    }
}
```
~ Must {#dotnet-proxy-client-name}
name service client types with the _Client_ suffix, e.g. ```ConfigurationClient```.
~

~ Must {#dotnet-proxy-client-namespace}
place service clients in the root namespace of their corresponsing component.
~

~ Must {#dotnet-proxy-class}
make service clients classes (reference types), not structs (value types).
~

~ Must {#dotnet-proxy-client-name}
see namespace design guidelines (below) for how to choose the namespace for the client types.
~

### Service Client Constructors

~ Must {#dotnet-proxy-class-ctor}
provide a constructor that takes just the parameters required to bind to and authenticate with the service, e.g. endpoint and authentication information. See the Authentication section (below) for more details.
~

~ Must {#dotnet-proxy-class-ctor-overloads}
provide constructor overloads that allow to specify a custom pipeline and optionally other service specific options, e.g. service API version.

The pipeline is a helper library that wraps ```System.Net.Http.HttpClient``` to ensure that all service calls do proper logging, telemetry, and retries. Custom pipeline allows the caller to alter default retry semantics and other aspects

For example, the ```ConfigurationClient``` type and its constructors look as follows:

```csharp
namespace Azure.ApplicationModel.Configuration {
    
    public class ConfigurationClient {
        public ConfigurationClient(string connectionString);
        public ConfigurationClient(string connectionString, HttpPipeline pipeline);    
    }
}
```
~

### Service Methods
This section describes guidelines for designing service client methods that call service endpoints. 
As a quick illustration, here are the main service call methods in the ConfigurationClient, and further below detailed guidelines codyfining various elements of the design.

```csharp
public class ConfigurationClient {

    public Task<Response<ConfigurationSetting>> AddAsync(ConfigurationSetting setting, CancellationToken cancellation = default);
    public Task<Response<ConfigurationSetting>> SetAsync(ConfigurationSetting setting, CancellationToken cancellation = default);
    public Task<Response<ConfigurationSetting>> UpdateAsync(ConfigurationSetting setting, CancellationToken cancellation = default);

    public Task<Response<ConfigurationSetting>> GetAsync(string key, SettingFilter filter = null, CancellationToken cancellation = default);
    public Task<Response<ConfigurationSetting>> DeleteAsync(string key, SettingFilter filter = null, CancellationToken cancellation = default);
}
```

~ Must {#dotnet-method-async}
make all methods that can result in network I/O async, i.e. return ```Task``` or ```ValueTask``` and suffix the method name with “Async”.
~

~ Must {#dotnet-method-cancellation}
ensure all async methods take an optional ```CancellationToken``` parameter called “cancellation”.
~

~ Must {#dotnet-method-return}
return ```Task<Response<T>>``` or ```ValueTask<Response<T>>``` from service methods, where T represents the content of the response and we will refer to it as the service call return type. See more below on the details for how to design service return types.
~

~ Must {#dotnet-method-impl}
use ```Azure.Core.HttpPipeline``` to implement all service call methods.
~

### Service Method Return Types

As mentioned above, service methods should return ```Task<Response<T>>``` (or equivalent). The ```T``` can be ```System.IO.Stream``` in case of untyped results (e.g. content of a storage blob) or a custom type representing deserialized response content. This section describes how such custom type and all its transitive closure dependencies (return type graph) should be designed.

~ Must {#dotnet-model-types}
ensure all types of the return type graph are:

1. immutable if they are not intended to be mutated by the caller.
2. structs if they are small and classes if they are large, per .NET Framework Design Guidelines.
3. implement basic data type guidelines, per .NET Framework Design Guidelines, e.g. implement ```IEquatable<T>```.
~

~ Should {#dotnet-model-type-serialization}
consider deserializing the return type lazily if the type is a large graph containing reference types. 
This allows callers to avoid large number of GC heap allocations. ```Response<T>``` allows for such lazy deserialization. See ```Response<T>``` documentation for how to do it.
~

### Namespace Naming

~ Must {#dotnet-namespace-registration}
register all namespaces with *adparch@microsoft.com*,
i.e. send email about your proposed namespaces to this address to start a discussion.
~

~ Must {#dotnet-namespace-format}
adhere to the following scheme when choosing a namespace: `Azure.<group>.<service>[.<feature>]`. For example, `Azure.Storage.Blobs`, or `Azure.CognitiveServices.Speech.Recognition`
~

~ MustNot {#dotnet-namespace-format-service-name}
place service API in second level namespace, e.g. `Azure.KeyVault`
~

~ Should {#dotnet-namespace-format-pre-approved}
use one of the following pre-approved namespace groups:

- ```Azure.Diagnostics``` (e.g. ```Azure.Diagnostics.OperationalInsights```)
- ```Azure.Cognitive``` (e.g. Azure.Cognitive.FaceRecognition```)
- ```Azure.Iot``` (e.g. Azure.Iot.Hub```)
- ```Azure.Networking``` (e.g. ```Azure.Networking.EventHub```)
- ```Azure.Runtime``` (e.g. ```Azure.Runtime.VirtualMachines```)
- ```Azure.Security``` (e.g. ```Azure.Security.KeyVault```)
- ```Azure.Storage``` (e.g. ```Azure.Storage.Blobs```)
~

## Authentication

Service proxy constructors should take all parameters required to create a functioning proxy, i.e. after the constructor is called service methods can be called successfully. Typically such parameters will include service endpoint information and everything needed to authenticate with the service.

## Error Reporting

~ Must {#dotnet-error-exception}
throw ```Azure.Core.ResponseFailedException``` or its subtype when a service method fails with non-success status code. 

The exception is avaliable in ```Azure.Core``` package. For example, 
```csharp
if (response.Status != 200) {
    else throw new ResponseFailedException(response);
}
```
~
## Packaging

~ Must {#dotnet-packaging-nuget}
package all components as NuGet packages. Follow the .NET packaging guidelines.
~

~ Must {#dotnet-packaging-nuget-granularity}
name the package similar to the name of the main namespace of the component.
For example, if the component is in ```Azure.Storage.Blob``` namespaces, the component dll should be called ```Azure.Storage.Blob.dll```, and the NuGet package should be called ```Azure.Storage.Blob```.
~

~ Should {#dotnet-packaging-nuget-granularity}
place small related components in similar lifecycle stages (i.e. evolving together) into a single NuGet package.
~

~ Must {#dotnet-packaging-ns}
build all components for .NET Standard 2.0 and .NET 4.6.
This can be acomplished by the following target setting in the csproj file:
```
<TargetFramework>netstandard2.0;net46</TargetFramework>
```
~

## Dependendencies

~ MustNot {#dotnet-packaging-ns}
have dependencies on any NuGet packages besides:

1. The .NET Standard, 
2. packages produced by the Azure Developer Platfrom team, 
3. packages produced by your team.
~

## Versioning

~ Must {#dotnet-compatibility}
follow same backward compatibility rules as .NET Core, i.e. be 100% backward compatible between versions of packages.
See TBD for detailed .NET breaking change rules.
~

~ Must {#dotnet-service-version-default}
call a highest supported service API version by default.
~

~ Must {#dotnet-service-version-option}
allow changing to an older supported service API versions when instantiating service client types. 
~

~ Must {#dotnet-package-sxs}
introduce a new package, with new assembly names, new namespace names, and new type names if you must do a breaking change. This should happen very rarely, if ever. 
~

~ Must {#dotnet-tester-doer}
use tester-doer .NET pattern or ```Nullable<T>```, if some API is not supported based on proxy configuration, e.g. service API version.

For example, 
```csharp
if (client.CanBatch) {
    Response<SettingBatch> response = await client.GetBatch("some_key*");
    Guid? Guid = response.Result.Guid;
}
else {
    Response<ConfigurationSetting> response1 = await client.GetAsync("some_key1");
    Response<ConfigurationSetting> response2 = await client.GetAsync("some_key2");
    Response<ConfigurationSetting> response3 = await client.GetAsync("some_key3");
    …
}
```
~
## Repository Guidelines

~ Must {#dotnet-repository}
have samples, readme, and prescribed folder structure. The README.md file must be in the component's root folder. 
~

~ Must {#dotnet-samples-hello_world}
have a sample file called ```S1_HelloWorld.cs```. All other samples are ordered from simplest to most complex using ```S<number>_``` prefix.
~

## Common Type Usage

~ Must {#dotnet-usage-etag}
use ```Azure.Core.ETag``` to represent ETags.
~

~ Must {#dotnet-usage-uri}
use ```System.Uri``` to represent URIs.
~

### Using HttpPipeline
TBD

## Commonly Overlooked .NET API Design Guidelines { @h1-h2: "A" }

Some .NET Design Guidelines have been notoriously overlooked in existing Azure SDKs. This section serves as a way to highlight these guidelines.

~ MustNot {#dotnet-no-abstractions}
have abstractions (interfaces of abstract classes) unless types both implement and consume them (i.e. you have parameters typed as the abstraction).
~

~ MustNot {#dotnet-no-interfaces-for-abstract-classes}
use interfaces if you can use abstract classes. The only reasons to use an interface are: a) you need to “multiple-inherit”, b) you want structs to implement and abstraction.
~

~ MustNot {#dotnet-no-generic-terms}
use very generic words and terms for type names, e.g. do not use names like “OperationResponse”, “DataCollection” etc.
~

~ ShouldNot {#dotnet-no-unclear-parameter-types}
use parameters types where it’s not clear what valid values are supported, e.g. string parameters are often like that.
~

~ MustNot {#dotnet-no-empty-types}
have empty types (types with no members)
~
